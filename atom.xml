<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>asxalex&#39;s blog</title>
  <subtitle>asxalex</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://asxalex.pw/"/>
  <updated>2017-02-10T02:09:15.515Z</updated>
  <id>http://asxalex.pw/</id>
  
  <author>
    <name>asxalex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vfs浅析（一）—— 基本数据结构</title>
    <link href="http://asxalex.pw/2017/02/09/vfs/"/>
    <id>http://asxalex.pw/2017/02/09/vfs/</id>
    <published>2017-02-09T07:57:33.000Z</published>
    <updated>2017-02-10T02:09:15.515Z</updated>
    
    <content type="html"><![CDATA[<p>vfs（virtual file system）为各种不同的文件系统提供了一个统一的接口，将不同的linux支持的文件系统类型的细节隐藏起来。vfs的设计利用的面向对象的概念，从而使实际文件系统的开发更便捷，成本更低。</p>
<p>linux通过vfs引入了一个通用文件模型，实际文件系统的开发只需将实际文件系统的组织结构转换为vfs的通用文件模型。<a id="more"></a></p>
<p>vfs通用文件模型引入了以下的对象：</p>
<ul>
<li>超级块（super block）：该对象存放已安装文件系统的相关信息及操作；</li>
<li>索引节点对象（大名鼎鼎的inode结构）：该对象存放具体文件的相关信息和操作，内核通过该对象管理文件系统上的文件；</li>
<li>文件对象（file结构）：在linux系统中表示一个已打开的文件的相关信息和操作；</li>
<li>目录想对象（dentry结构）：存放目录想与对应文件进行连接的有关信息；</li>
</ul>
<p>在linux系统中，所有挂载的文件系统均由一个<code>super_blocks</code>链表指定，当一个实际的文件系统被<code>mount</code>命令挂载，则会生成对应的结构，串联到该链表之上。</p>
<h2 id="vfs数据结构"><a href="#vfs数据结构" class="headerlink" title="vfs数据结构"></a>vfs数据结构</h2><p>以上四种通用文件模型涉及的对象均包含属性和一组相关操作集。</p>
<h3 id="super-block"><a href="#super-block" class="headerlink" title="super block"></a>super block</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in include/linux/fs.h</span></div><div class="line"><span class="keyword">struct</span> super_block &#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 通过s_list, 具体的super block对象被挂接到super_blocks链表上</div><div class="line">     */</div><div class="line">    <span class="keyword">struct</span> list_head s_list;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * some other info</div><div class="line">     */</div><div class="line">    <span class="keyword">dev_t</span> s_dev;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_blocksize;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> s_dirt;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> s_maxbytes;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> super_operations *s_op; <span class="comment">/* 超级块操作 */</span></div><div class="line">    <span class="keyword">struct</span> dentry *s_root; <span class="comment">/* 挂载的root */</span></div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>与超级块操作的相关方法在<code>s_op</code>成员中，里面有一系列操作，包括：</p>
<ul>
<li>超级块的挂载相关的操作，比如<code>remount_fs</code>， <code>umount_begin</code>等；</li>
<li>inode相关的操作，比如<code>alloc_inode</code>， <code>destroy_inode</code>等；</li>
<li>统计信息类操作，比如<code>statfs</code>等；</li>
</ul>
<p>利用这个通用的文件系统模型，实际的文件系统定义这些操作，当某个文件系统需要重新挂载时，只需调用<code>sb-&gt;s_op-&gt;remount_fs</code>即可。</p>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>文件系统的文件信息都存放在inode结构中，当一个文件被创建时，相应的inode结构也被创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> inode &#123;</div><div class="line">    <span class="keyword">umode_t</span> i_mode;</div><div class="line">    unsighed <span class="keyword">short</span> i_opflags;</div><div class="line">    <span class="keyword">kuid_t</span> i_uid;</div><div class="line">    <span class="keyword">kgid_t</span> i_gid;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i_flags;</div><div class="line">    ...</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> inode_operations *i_op;</div><div class="line">    <span class="keyword">struct</span> super_block *i_sb;</div><div class="line">    ...</div><div class="line">    <span class="keyword">struct</span> timespec i_atime;</div><div class="line">    <span class="keyword">struct</span> timespec i_mtime;</div><div class="line">    <span class="keyword">struct</span> timespec i_ctime;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>inode结构记录了文件的模式，所属用户，用户组，修改时间等一系列信息。同样，inode结构有属于自己的操作集<code>i_op</code>成员，用于inode目录项下的相关操作。</p>
<h3 id="file结构"><a href="#file结构" class="headerlink" title="file结构"></a>file结构</h3><p>file结构代表进程中打开的一个文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> file &#123;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> list_head fu_list;</div><div class="line">        <span class="keyword">struct</span> rcu_head fu_rcuhead;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">struct</span> path f_path;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> f_dentry f_path.dentry</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> f_vfsmnt f_path.mnt</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *f_op;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="keyword">fmode_t</span> f_mode;</div><div class="line">    <span class="keyword">loff_t</span> f_pos;</div><div class="line">    <span class="keyword">struct</span> fown_struct f_owner;</div><div class="line">    ...</div><div class="line">    <span class="keyword">void</span> *private_data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>file结构的操作集应该是我们最熟悉的，普通的read，write等系统调用最后均会使用到<code>f_op</code>成员中定义的操作。</p>
<h3 id="dentry结构"><a href="#dentry结构" class="headerlink" title="dentry结构"></a>dentry结构</h3><p>vfs将目录看作是由若干子目录和文件组成的一个普通文件，当一个目录项被读入内存，则被转成由dentry表示的目录项对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> dentry &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">struct</span> dentry *d_parent;</div><div class="line">    <span class="keyword">struct</span> inode *d_inode;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> dentry_operations *d_op;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里只是简单地介绍了一下vfs中几个重要的对象结构，之后会找个时间好好研究一下vfs具体操作，包括一个分区的挂载，在分区中创建文件，在进程中打开新建的文件等，以便更微观地了解vfs。</p>
<p>（TO BE CONTINUED）</p>
<p>注： 这里使用的内核代码为3.8版本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vfs（virtual file system）为各种不同的文件系统提供了一个统一的接口，将不同的linux支持的文件系统类型的细节隐藏起来。vfs的设计利用的面向对象的概念，从而使实际文件系统的开发更便捷，成本更低。&lt;/p&gt;
&lt;p&gt;linux通过vfs引入了一个通用文件模型，实际文件系统的开发只需将实际文件系统的组织结构转换为vfs的通用文件模型。
    
    </summary>
    
    
      <category term="Kernel" scheme="http://asxalex.pw/tags/Kernel/"/>
    
      <category term="Linux" scheme="http://asxalex.pw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux等待队列</title>
    <link href="http://asxalex.pw/2017/02/03/waitqueue/"/>
    <id>http://asxalex.pw/2017/02/03/waitqueue/</id>
    <published>2017-02-03T02:21:50.000Z</published>
    <updated>2017-02-03T07:35:48.459Z</updated>
    
    <content type="html"><![CDATA[<p>等待队列允许进程在某个特定的事件上等待，在事件发生时唤醒进程继续执行。Linux内核中等待队列由队列头和队列元素构成：</p>
<a id="more"></a>
<figure class="highlight c"><figcaption><span>include/linux/wait.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __wait_queue_head &#123;</div><div class="line">    <span class="keyword">spinlock_t</span> lock;</div><div class="line">    <span class="keyword">struct</span> list_head task_list;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __wait_queue_head <span class="keyword">wait_queue_head_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __wait_queue &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE 0x01</span></div><div class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</div><div class="line">    <span class="keyword">wait_queue_func_t</span> func;</div><div class="line">    <span class="keyword">struct</span> list_head task_list;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __wait_queue <span class="keyword">wait_queue_t</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*<span class="keyword">wait_queue_func_t</span>)</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> flags, <span class="keyword">void</span> *key)</span></span>;</div></pre></td></tr></table></figure>
<p>队列头和元素之间通过<code>struct list_head</code>构成一个循环双向链表，结构如下图所示：</p>
<p><img src="http://asxalex.qiniudn.com/wait_queue.png" alt="wait_queue"></p>
<p>等待队列通过队列头和队列节点，将<code>private</code>串联起来（实际使用中，通常是将进程描述符存放于此，形成进程的等待队列，以便于进程的管理）。<code>wait_queue_head_t</code>的<code>lock</code>用于对该等待队列的加锁操作，以防止竟态。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>等待队列头的初始化：</p>
<figure class="highlight c"><figcaption><span>include/linux/wait.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __WAIT_QUEUE_HEAD_INITIALIZER(name) &#123; \</span></div><div class="line">    .lock = __SPIN_LOCK_UNLOCKED(name.lock), \</div><div class="line">    .task_list = &#123; &amp;(name).task_list, &amp;(name).task_list&#125; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></div><div class="line">    wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</div></pre></td></tr></table></figure>
<p>等待队列头的初始化主要是声明一个队列头对象，然后将<code>lock</code>置于未上锁的状态，而<code>task_list</code>初始化为一个空的队列，<code>next</code>与<code>prev</code>均指向自己。</p>
<p>等待队列元素的初始化</p>
<figure class="highlight c"><figcaption><span>include/linux/wait.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __WAITQUEUE_INITIALIZER(name, tsk) &#123; \</span></div><div class="line">    .private = tsk, \</div><div class="line">    .func = default_wake_function, \</div><div class="line">    .task_list = &#123;NULL, NULL&#125; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DECALRE_WAITQUEUE(name, tsk) \</span></div><div class="line">    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)</div></pre></td></tr></table></figure>
<p>类似的，<code>wait_queue_t</code>的各个成员被初始化为相应的值。注意到这里的<code>func</code>成员被初始化为<code>default_wake_function</code>，该函数调用<code>try_to_wake_up()</code>，执行一个默认的唤醒进程的操作，具体代码在<code>kernel/sched/core.c</code>中。</p>
<h2 id="等待队列元素的添加和移除"><a href="#等待队列元素的添加和移除" class="headerlink" title="等待队列元素的添加和移除"></a>等待队列元素的添加和移除</h2><p><code>add_wait_queue</code>负责向一个等待队列中添加新的元素：</p>
<figure class="highlight c"><figcaption><span>kernel/wait.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">wait_queue_t</span> *wait)</span> </span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</div><div class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</div><div class="line">    __add_wait_queue(q, wait);</div><div class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __add_wait_queue(<span class="keyword">wait_queue_head_t</span> *head, <span class="keyword">wait_queue_t</span> *<span class="keyword">new</span>) &#123;</div><div class="line">    list_add(&amp;<span class="keyword">new</span>-&gt;task_list, &amp;head-&gt;task_list);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数需要处理元素的排他属性以及操作队列的互斥问题，之后实际的操作只是将该元素插入到等待队列头的位置。另外有个类似的<code>add_wait_queue_exclusive()</code>，该函数完成工作类似，只是设置了元素的排他属性。</p>
<p><code>remove_wait_queue</code>则处理元素的离队操作，依次调用<code>__remove_wait_queue() -&gt; list_del()</code>。</p>
<h2 id="等待事件的处理"><a href="#等待事件的处理" class="headerlink" title="等待事件的处理"></a>等待事件的处理</h2><p>等待队列的用途就是让进程等待特定事件的发生，在事件发生之后唤醒相应的进程。</p>
<h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>由<code>wait_event*</code>族函数完成，这些函数将进程置于不同的状态让其休眠，等到特定事件发生时，由<code>wake_up*</code>族函数唤醒休眠的进程：</p>
<figure class="highlight c"><figcaption><span>include/linux/wait.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __wait_event(wq, condition) \</span></div><div class="line">do &#123; \</div><div class="line">    DEFINE_WAIT(__wait); \</div><div class="line">    for (;;) &#123; \</div><div class="line">        prepare_to_wait(&amp;wq, &amp;__wait, TASK_UNINTERRUPTIBLE); \</div><div class="line">        <span class="meta-keyword">if</span> (condition) \</div><div class="line">            break; \</div><div class="line">        schedule(); \</div><div class="line">    &#125; \</div><div class="line">    finish_wait(&amp;wq, &amp;__wait); \</div><div class="line">&#125; while(0)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_event(wq, condition) \</span></div><div class="line">do &#123; \</div><div class="line">    <span class="meta-keyword">if</span> (condition) \</div><div class="line">        break; \</div><div class="line">    __wait_event(wq, condition); \</div><div class="line">while(0)</div></pre></td></tr></table></figure>
<p>在<code>wait</code>之前，会先检查一下该条件是否为真，若为真，则不用休眠，继续执行，否则，将当前进程的状态设置为<code>TASK_UNIERRUPTIBLE</code>，并加入队列，准备进行休眠，在休眠之前，会再次检查<code>condition</code>是否为真（为了防止条件在该进程被调度之前就为真，此时就可能丢失了唯一一次唤醒的机会，导致该进程永久休眠），如果条件确实还没为真，则调用调度器让出CPU，自己进入休眠状态。</p>
<h3 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h3><p>唤醒由<code>wake_up*</code>族函数完成</p>
<figure class="highlight c"><figcaption><span>include/linux/wait.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> wake_up(x) __wake_up(x, TASK_NORMEL, 1, NULL);</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> __wake_up(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode, <span class="keyword">int</span> nr_execlusive, <span class="keyword">void</span> *key) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);</div><div class="line">    __wake_up_common(q, mode, nr_execlusive, <span class="number">0</span>, key);</div><div class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __wake_up_common(<span class="keyword">wait_queue_head_t</span> *q, <span class="keyword">unsigned</span> <span class="keyword">int</span> mode,</div><div class="line">        <span class="keyword">int</span> nr_execlusive, <span class="keyword">int</span> wake_flags, <span class="keyword">void</span> *key) &#123;</div><div class="line">    <span class="keyword">wait_queue_t</span> *curr, *next;</div><div class="line">    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;</div><div class="line">        <span class="keyword">unsigned</span> flags  = curr-&gt;flags;</div><div class="line">        <span class="keyword">if</span> (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;</div><div class="line">                (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_execlusive)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心函数是<code>__wake_up_common</code>，它遍历等待队列上的所有元素，并调用对应的<code>func</code>函数指针，在这里，如果某一元素的<code>func()</code>执行完之后返回0，则退出，不唤醒剩余的进程。</p>
<p>其中的<code>nr_execlusive</code>成员指示可以唤醒队列中多少个标识了<code>WQ_FLAG_EXCLUSIVE</code>的元素。</p>
<p>被唤醒之后，该进程从睡眠时的<code>schedule()</code>处继续执行，此时会再次判断条件是否为真，如为真，则退出休眠，继续执行<code>wait_event</code>之后的逻辑代码，否则继续休眠。</p>
<p><code>wait_event*</code>与<code>wake_up*</code>分别负责等待和唤醒某个等待队列上的进程。</p>
<p>（以上）</p>
<p>注： 这里使用的内核代码为3.8版本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;等待队列允许进程在某个特定的事件上等待，在事件发生时唤醒进程继续执行。Linux内核中等待队列由队列头和队列元素构成：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kernel" scheme="http://asxalex.pw/tags/Kernel/"/>
    
      <category term="Linux" scheme="http://asxalex.pw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>kprobes使用</title>
    <link href="http://asxalex.pw/2017/01/21/kprobesexample/"/>
    <id>http://asxalex.pw/2017/01/21/kprobesexample/</id>
    <published>2017-01-21T03:42:02.000Z</published>
    <updated>2017-01-21T04:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>室友是做安全的，有一天他发现有个本地的进程一直在尝试用弱口令连接他的<code>mysql</code>，所以想把这个进程找出来。所以我们一起研究了一下<code>kprobes</code>，通过<code>kprobes</code>可以在内核的<code>connect</code>上植入一个钩子，当任何进程要进行网络连接时，就可以对该进程进行记录。<a id="more"></a></p>
<h2 id="jprobes"><a href="#jprobes" class="headerlink" title="jprobes"></a>jprobes</h2><p>我们最先想到的是<code>jprobes</code>，我们可以定义一个原型与内核中<code>sys_connect</code>一样的函数，然后通过<code>jprobes</code>植入我们的函数钩子，在真正的<code>sys_connect</code>被执行之前，内核会复制一份环境和参数给我们定义的钩子函数，在函数执行完之后，才会返回去执行内核的<code>sys_connect</code>。</p>
<p>但在看内核代码之后，我们发现：当一个进程使用<code>connect</code>进行socket的连接时，在没有调用<code>bind</code>进行地址绑定时（一般客户端进程不会调用<code>bind</code>进行地址绑定，而是让内核去指定一个随机的端口进行连接传输），内核是在<code>sys_connect</code>函数执行时才会分配地址，所以，我们的钩子函数此时根本无法得到本地进程进行连接时所使用的端口。</p>
<h2 id="kretporbes"><a href="#kretporbes" class="headerlink" title="kretporbes"></a>kretporbes</h2><p>后来我们又转到了<code>kretporbes</code>，同它的名字一样，它是在被探测函数执行返回后执行的探测点，同时，它也允许我们在被探测函数执行前执行我们定义的另外一个辅助函数，我们使用该特性来保存进入<code>sys_connect</code>时候的参数，然后在它执行退出之后，就可以得到里面被填充的信息，得到源目地址和源目端口了。</p>
<p>在加载模块之后，我们执行<code>curl www.baidu.com</code>，可以得到下面的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[  <span class="number">103.151319</span>] sys_connect[<span class="number">0</span>]: task[curl] pid[<span class="number">31979</span>] fd[<span class="number">4</span>] from localport[<span class="number">172.16</span><span class="number">.38</span><span class="number">.129</span>:<span class="number">56265</span>] -&gt; dest[<span class="number">172.16</span><span class="number">.38</span><span class="number">.2</span>:<span class="number">53</span>]</div><div class="line">[  <span class="number">103.161065</span>] sys_connect[<span class="number">0</span>]: task[curl] pid[<span class="number">31979</span>] fd[<span class="number">3</span>] from localport[<span class="number">172.16</span><span class="number">.38</span><span class="number">.129</span>:<span class="number">34474</span>] -&gt; dest[<span class="number">111.13</span><span class="number">.100</span><span class="number">.91</span>:<span class="number">80</span>]</div><div class="line">[  <span class="number">103.161069</span>] sys_connect[<span class="number">0</span>]: task[curl] pid[<span class="number">31979</span>] fd[<span class="number">3</span>] from localport[<span class="number">172.16</span><span class="number">.38</span><span class="number">.129</span>:<span class="number">43288</span>] -&gt; dest[<span class="number">111.13</span><span class="number">.100</span><span class="number">.92</span>:<span class="number">80</span>]</div><div class="line">[  <span class="number">103.162693</span>] sys_connect[<span class="number">-115</span>]: task[curl] pid[<span class="number">31978</span>] fd[<span class="number">3</span>] from localport[<span class="number">172.16</span><span class="number">.38</span><span class="number">.129</span>:<span class="number">56294</span>] -&gt; dest[<span class="number">111.13</span><span class="number">.100</span><span class="number">.91</span>:<span class="number">80</span>]</div></pre></td></tr></table></figure>
<p>可以看到<code>curl</code>首先进行了一次DNS查询，之后才去连接对应的ip地址。</p>
<p><a href="https://github.com/asxalex/connect-hook" target="_blank" rel="external">happy hacking code</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题起源&quot;&gt;&lt;a href=&quot;#问题起源&quot; class=&quot;headerlink&quot; title=&quot;问题起源&quot;&gt;&lt;/a&gt;问题起源&lt;/h2&gt;&lt;p&gt;室友是做安全的，有一天他发现有个本地的进程一直在尝试用弱口令连接他的&lt;code&gt;mysql&lt;/code&gt;，所以想把这个进程找出来。所以我们一起研究了一下&lt;code&gt;kprobes&lt;/code&gt;，通过&lt;code&gt;kprobes&lt;/code&gt;可以在内核的&lt;code&gt;connect&lt;/code&gt;上植入一个钩子，当任何进程要进行网络连接时，就可以对该进程进行记录。
    
    </summary>
    
    
      <category term="Fun" scheme="http://asxalex.pw/tags/Fun/"/>
    
      <category term="Kernel" scheme="http://asxalex.pw/tags/Kernel/"/>
    
      <category term="Linux" scheme="http://asxalex.pw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>kprobe浅析</title>
    <link href="http://asxalex.pw/2017/01/16/kprobe/"/>
    <id>http://asxalex.pw/2017/01/16/kprobe/</id>
    <published>2017-01-16T05:38:55.000Z</published>
    <updated>2017-01-16T11:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>kprobe可以动态向内核注册一个调试点，用户定义好钩子函数，当该点被内核执行到时，就调用钩子函数。kprobe可以被方便地用来调试内核，也可以用来实现一些内核设施的统计等（当然，会有额外开销）</p>
<p>kprobes的使用可以参考内核的<code>samples/kprobes</code>目录下的文件，这些文件可以编译为内核模块，在加载到内核之后就可以使用。</p>
<p>kprobe有不同的种类，分别为<code>kprobes</code>，<code>jprobes</code>和<code>kretprobes</code>，这里只讨论其中的<code>kprobes</code>。<a id="more"></a></p>
<h2 id="kprobe的初始化"><a href="#kprobe的初始化" class="headerlink" title="kprobe的初始化"></a>kprobe的初始化</h2><p>kprobe也是一个内核模块，在系统初始化的时候被一起初始化。初始化由定义在<code>kernel/kprobes.c</code>中，主要完成的工作有：</p>
<ul>
<li>初始化kprobe哈希链表头节点，为了提高搜索效率，所有注册的kprobe都被放置到这个kprobe哈希链表（<code>kprobe_table</code>）中。</li>
<li>初始化kprobe黑名单，在一些关键函数处禁止放置kprobe探测点（包括<code>preempt_schedule</code>，<code>native_get_debugreg</code>等，该黑名单由<code>kprobe_blacklist</code>指定）。</li>
<li>向事件通知链表注册kprobe通知事件</li>
</ul>
<figure class="highlight c"><figcaption><span>kernel/kprobes.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_kprobes</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 初始化kprobe哈希链表头节点</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KPROBE_TABLE_SIZE; i++) &#123;</div><div class="line">        INIT_HLIST_HEAD(&amp;kprobe_table[i]);</div><div class="line">        INIT_HLIST_HEAD(&amp;kretprobe_inst_table[i]);</div><div class="line">        raw_spin_lock_init(&amp;(kretprobe_table_locks[i].lock));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 初始化kprobe黑名单</span></div><div class="line">    <span class="keyword">for</span> (kb = kprobe_blacklist; kb-&gt;name != <span class="literal">NULL</span>; kb++) &#123;</div><div class="line">        kprobe_lookup_name(kb-&gt;name, addr);</div><div class="line">        <span class="keyword">if</span> (!addr)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        kb-&gt;start_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr;</div><div class="line">        symbol_name = kallsyms_lookup(kb-&gt;start_addr,&amp;size, &amp;offset, &amp;modname, namebuf);</div><div class="line">        <span class="keyword">if</span> (!symbol_name)</div><div class="line">            kb-&gt;range = <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            kb-&gt;range = size;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 注册kprobe事件通知链表</span></div><div class="line">    ...</div><div class="line">    err = register_die_notifier(&amp;kprobe_exceptions_nb);</div><div class="line">    ...</div><div class="line">    err = register_module_notifier(&amp;kprobe_module_nb);</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注册一个kprobe"><a href="#注册一个kprobe" class="headerlink" title="注册一个kprobe"></a>注册一个kprobe</h2><p>在需要注入一个已经被初始化的探测点（填写<code>struct kprobe</code>结构）的时候，需要调用<code>register_kprobe</code>函数。该函数首先对传递进来的<code>kprobe</code>结构体填充更完整的信息，并计算出探测点的具体位置，并会对该位置做许多精细的检查。在做完一系列检查之后，会将他测点插入到上面已经初始化过的<code>kprobe_table</code>中。</p>
<p>注册一个kprobe的关键步骤的调用链为： <code>register_kprobe -&gt; arm_kprobe -&gt; __arm_kprobe -&gt; arch_arm_kprobe -&gt; text_poke</code>，最关键的<code>text_poke</code>如下：</p>
<figure class="highlight c"><figcaption><span>arch/x86/kernel/alternative.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * text_poke - Update instructions on a live kernel</div><div class="line"> * @addr: address to modify</div><div class="line"> * @opcode: source of the copy</div><div class="line"> * @len: length to copy</div><div class="line"> *</div><div class="line"> * Only atomic text poke/set should be allowed when not doing early patching.</div><div class="line"> * It means the size must be writable atomically and the address must be aligned</div><div class="line"> * in a way that permits an atomic write. It also makes sure we fit on a single</div><div class="line"> * page.</div><div class="line"> *</div><div class="line"> * Note: Must be called under text_mutex.</div><div class="line"> */</div><div class="line"><span class="keyword">void</span> *__<span class="function">kprobes <span class="title">text_poke</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">const</span> <span class="keyword">void</span> *opcode, <span class="keyword">size_t</span> len)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* start of section1 */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">	<span class="keyword">char</span> *vaddr;</div><div class="line">	<span class="keyword">struct</span> page *pages[<span class="number">2</span>];</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!core_kernel_text((<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr)) &#123;</div><div class="line">		pages[<span class="number">0</span>] = vmalloc_to_page(addr);</div><div class="line">		pages[<span class="number">1</span>] = vmalloc_to_page(addr + PAGE_SIZE);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		pages[<span class="number">0</span>] = virt_to_page(addr);</div><div class="line">		WARN_ON(!PageReserved(pages[<span class="number">0</span>]));</div><div class="line">		pages[<span class="number">1</span>] = virt_to_page(addr + PAGE_SIZE);</div><div class="line">	&#125;</div><div class="line">	BUG_ON(!pages[<span class="number">0</span>]);</div><div class="line">	local_irq_save(flags);</div><div class="line">	set_fixmap(FIX_TEXT_POKE0, page_to_phys(pages[<span class="number">0</span>]));</div><div class="line">	<span class="keyword">if</span> (pages[<span class="number">1</span>])</div><div class="line">		set_fixmap(FIX_TEXT_POKE1, page_to_phys(pages[<span class="number">1</span>]));</div><div class="line">	vaddr = (<span class="keyword">char</span> *)fix_to_virt(FIX_TEXT_POKE0);</div><div class="line">    <span class="comment">/* end of section1 */</span></div><div class="line"></div><div class="line">	<span class="built_in">memcpy</span>(&amp;vaddr[(<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr &amp; ~PAGE_MASK], opcode, len);</div><div class="line"></div><div class="line">    <span class="comment">/* start of section2 */</span></div><div class="line">	clear_fixmap(FIX_TEXT_POKE0);</div><div class="line">	<span class="keyword">if</span> (pages[<span class="number">1</span>])</div><div class="line">		clear_fixmap(FIX_TEXT_POKE1);</div><div class="line">	local_flush_tlb();</div><div class="line">	sync_core();</div><div class="line">	<span class="comment">/* Could also do a CLFLUSH here to speed up CPU recovery; but</span></div><div class="line">	   that causes hangs on some VIA CPUs. */</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">		BUG_ON(((<span class="keyword">char</span> *)addr)[i] != ((<span class="keyword">char</span> *)opcode)[i]);</div><div class="line">	local_irq_restore(flags);</div><div class="line">    <span class="comment">/* end of section2 */</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如代码所示，<code>section1</code>主要是根据参数确定需要修改处的内核的虚拟地址，其中包括确定是核心的还是模块的虚拟地址等，其中还涉及到固定映射等方面。完成实际的工作就是一个简单的<code>memcpy</code>函数，将opcode拷贝到该地址处，此时的opcode为<code>BREAKPOINT_INSTRUCTION（0x33，对应x86的指令为int 3）</code>。<code>section2</code>部分代码主要做一些清理和检查工作。</p>
<h2 id="触发一个kprobe"><a href="#触发一个kprobe" class="headerlink" title="触发一个kprobe"></a>触发一个kprobe</h2><p>在我们需要的地方埋好<code>int 3</code>指令之后，当内核执行相应的命令时，当遇到该指令，会触发<code>int 3</code>：</p>
<figure class="highlight c"><figcaption><span>arch/x86/kernel/entry_32.S</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ENTRY(int3)</div><div class="line">    RING0_INT_FRAME</div><div class="line">    ...</div><div class="line">    call do_int3</div><div class="line">    ...</div><div class="line">END(int3)</div></pre></td></tr></table></figure>
<p>会沿着调用链<code>do_int3 -&gt; notify_die -&gt; atomic_notifier_call_chain -&gt; __atomic_notifier_call_chain -&gt; notifier_call_chain</code>直到<code>nb-&gt;notifier_call()</code>调用<code>notifier_call</code>，借用面向对象的思想，内核中kprobe的<code>notifier_call</code>的定义为：</p>
<figure class="highlight c"><figcaption><span>kernel/kprobes.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> notifier_block kprobe_exceptions_nb = &#123;</div><div class="line">    .notifier_call = kprobes_exceptions_notify,,</div><div class="line">    .priority = <span class="number">0x7fffffff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这导致了最终<code>kprobes_exceptions_nb</code>函数被调用，该函数先进行一些检查，然后调用了<code>kprobe_handler</code>，核心处理函数就是该函数。</p>
<figure class="highlight c"><figcaption><span>arch/x86/kernel/kprobes.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">kprobes <span class="title">kprobe_exceptions_notify</span><span class="params">(<span class="keyword">struct</span> notifier_block *self, <span class="keyword">unsigned</span> <span class="keyword">long</span> val, <span class="keyword">void</span> *data)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">switch</span> (val) &#123;</div><div class="line">        <span class="keyword">case</span> DIE_INT3:</div><div class="line">            <span class="keyword">if</span>(kprobe_handler(args-&gt;regs))</div><div class="line">                ret = NOTIFY_STOP;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">kprobes <span class="title">kprobe_handler</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    addr = (<span class="keyword">kprobe_opcode_t</span> *)(regs-&gt;ip - <span class="keyword">sizeof</span>(<span class="keyword">kprobe_opcode_t</span>));</div><div class="line">    kcb = get_kprobe_ctlblk();</div><div class="line">    p = get_kprobe(addr);</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (p) &#123;</div><div class="line">        <span class="keyword">if</span> (kprobe_running()) &#123;</div><div class="line">            ... <span class="comment">// re-enter the kprobe</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            set_current_kprobe(p, regs, kcb);</div><div class="line">            kcb-&gt;kprobe_status = KPROBE_HIT_ACTIVE;</div><div class="line">            <span class="keyword">if</span>(!p-&gt;pre_handler || !p-&gt;pre_handler(p, regs))</div><div class="line">                setup_singlestep(p, regs, kcb, <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此，kprobe中定义的<code>pre_handler</code>被调用。此时还会根据用户定义的函数返回值，判断是否要设置TF值进行单步执行等。</p>
<p>注：代码所使用的内核版本为3.8</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kprobe可以动态向内核注册一个调试点，用户定义好钩子函数，当该点被内核执行到时，就调用钩子函数。kprobe可以被方便地用来调试内核，也可以用来实现一些内核设施的统计等（当然，会有额外开销）&lt;/p&gt;
&lt;p&gt;kprobes的使用可以参考内核的&lt;code&gt;samples/kprobes&lt;/code&gt;目录下的文件，这些文件可以编译为内核模块，在加载到内核之后就可以使用。&lt;/p&gt;
&lt;p&gt;kprobe有不同的种类，分别为&lt;code&gt;kprobes&lt;/code&gt;，&lt;code&gt;jprobes&lt;/code&gt;和&lt;code&gt;kretprobes&lt;/code&gt;，这里只讨论其中的&lt;code&gt;kprobes&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Kernel" scheme="http://asxalex.pw/tags/Kernel/"/>
    
      <category term="Linux" scheme="http://asxalex.pw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ptrace工作原理分析</title>
    <link href="http://asxalex.pw/2017/01/11/ptrace/"/>
    <id>http://asxalex.pw/2017/01/11/ptrace/</id>
    <published>2017-01-11T10:10:58.000Z</published>
    <updated>2017-01-11T10:21:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>ptrace提供了一种让一个程序（tracer）控制另一个程序（tracee）执行流程，甚至时修改被控制程序内存或者寄存器的方法，ptrace的man手册这样描述：</p>
<blockquote>
<p>The  ptrace()  system  call provides a means by which one<br>process (the “tracer”) may observe and control the execu‐<br>tion  of  another process (the “tracee”), and examine and<br>change the tracee’s memory and registers.  It is  primar‐<br>ily  used  to  implement  breakpoint debugging and system<br>call tracing.</p>
</blockquote>
<p>用户空间的每个进程，在内核中都有一个<code>task_struct</code>结构与之对应<a id="more"></a>，这里跟ptrace有关的结构成员为：</p>
<figure class="highlight c"><figcaption><span>include/linux/sched.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> task_struct &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * ptraced将所有被该进程trace的其他进程构成一个链表,</div><div class="line">     * 也包括了该进程的子进程</div><div class="line">     */</div><div class="line">    <span class="keyword">struct</span> list_head ptraced;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * ptrace_entry是该进程被trace之后，加入到</div><div class="line">     * parent-&gt;ptraced链表中的节点元素</div><div class="line">     */</div><div class="line">    <span class="keyword">struct</span> list_head ptrace_entry;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="ptrace的使用"><a href="#ptrace的使用" class="headerlink" title="ptrace的使用"></a>ptrace的使用</h2><p>在细致分析ptrace之前，先来看一下ptrace的使用方法，以下是网上很常见的示例性代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// trace.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reg.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">puts</span>(<span class="string">"Parent started"</span>);</div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    pid=fork();</div><div class="line">    <span class="keyword">if</span> (pid&lt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"fork() failed"</span>);</div><div class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>)&#123;</div><div class="line">        ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"Child sleeping..."</span>);</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"Child exec..."</span>);</div><div class="line">        execlp(<span class="string">"./target"</span>,<span class="string">"target"</span>,<span class="literal">NULL</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Child PiD == %d\n"</span>,pid);</div><div class="line">        <span class="keyword">int</span> sta=<span class="number">0</span>;</div><div class="line">        <span class="keyword">struct</span> rusage ru;</div><div class="line">        wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</div><div class="line">        <span class="keyword">long</span> rax_rt=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Child execve() returned with %ld\n"</span>,rax_rt);</div><div class="line">        ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> intocall=<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">            wait4(pid,&amp;sta,<span class="number">0</span>,&amp;ru);</div><div class="line">            <span class="keyword">if</span> (WIFEXITED(sta))&#123;</div><div class="line">                <span class="built_in">puts</span>(<span class="string">"Child Exited"</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">long</span> _ORIG_RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*ORIG_RAX,<span class="number">0</span>);</div><div class="line">            <span class="keyword">long</span> _RAX=ptrace(PTRACE_PEEKUSER,pid,<span class="number">8</span>*RAX,<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (intocall)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Entering SYSCALL %ld .... "</span>,_ORIG_RAX);</div><div class="line">                intocall=<span class="number">0</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Exited with %ld\n"</span>,_RAX);</div><div class="line">                intocall=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            ptrace(PTRACE_SYSCALL,pid,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// target.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc target.c -o target</div><div class="line">$ gcc trace.c -o trace</div><div class="line">$ ./trace</div></pre></td></tr></table></figure>
<p>即可看到结果，将target.c中的系统调用号和返回值打印了出来。</p>
<h2 id="ptrace系统调用分析"><a href="#ptrace系统调用分析" class="headerlink" title="ptrace系统调用分析"></a>ptrace系统调用分析</h2><p>ptrace系统调用在内核中调用了<code>sys_ptrace</code>函数：</p>
<figure class="highlight c"><figcaption><span>kernel/ptrace.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE4(ptrace, <span class="keyword">long</span>, request, <span class="keyword">long</span>, pid, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr,</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, data) &#123;</div><div class="line">    <span class="keyword">long</span> ret;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (request == PTRACE_TRACEME) &#123;</div><div class="line">        ret = ptrace_traceme(); <span class="comment">// 1</span></div><div class="line">        ...</div><div class="line">        <span class="keyword">goto</span> out1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> task_struct *child = ptrace_get_task_struct(pid);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (request == PTRACE_ATTACH || request == PTRACE_SEIZE) &#123;</div><div class="line">        ret = ptrace_attach(child, request, addr, data); <span class="comment">// 2</span></div><div class="line">        <span class="keyword">goto</span> out2;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    ...</div><div class="line">    ret = arch_ptrace(child, request, addr, data); <span class="comment">// 3</span></div><div class="line">    ...</div><div class="line"></div><div class="line">out2:</div><div class="line">    ...</div><div class="line">out1:</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>out*</code>跟内核的返回和资源收集等有关，这里不关心。这里重点分析三块标有数字的情况。</p>
<h3 id="tracee"><a href="#tracee" class="headerlink" title="tracee"></a>tracee</h3><p>正如在<code>ptrace使用</code>中的例子，<code>PTRACE_TRACEME</code>主要由<code>tracee</code>（被监控程序）调用，当将该标志位被传递给ptrace时，<code>1</code>处的<code>ptrace_traceme()</code>被调用，具体操作如下注释：</p>
<figure class="highlight c"><figcaption><span>kernel/ptrace.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ptrace_traceme</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ret = -EPERM;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 该进程还没有被trace的情况，</div><div class="line">     * 为了防止竞态条件，内核源码此处加锁了，此处忽略</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!current-&gt;ptrace) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 主要做一些权限检查，以确定父进程由CAP_SYS_PTRACE权限</div><div class="line">         */</div><div class="line">        ret = security_ptrace_traceme(current-&gt;parent);</div><div class="line">        <span class="keyword">if</span> (!ret &amp;&amp; !(current-&gt;real_parent-&gt;flags &amp; PF_EXITING)) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 这里主要设置进程的状态，以及将父子进程（tracer</div><div class="line">             * 和tracee）之间的链表关系，还记得task_struct的</div><div class="line">             * ptraced和ptrace_entry吧:)</div><div class="line">             */</div><div class="line">            current-&gt;ptrace = PT_PTRACED;</div><div class="line">            __ptrace_link(current, current-&gt;real_parent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这之后，tracee每次接收到信号（除了SIGKILL信号），它都会暂停，并将信号传递给tracer进程（具体在<code>do_signal</code>函数中），当tracer调用<code>wait</code>系列系统调用时可以获得此时tracee进程的状态。</p>
<h3 id="tracer"><a href="#tracer" class="headerlink" title="tracer"></a>tracer</h3><p>在tracee声明traceme之后，tracer就可以使用ptrace系统调用向tracee发送命令了，具体对应<code>2</code>和<code>3</code>注释那两块，<code>ptrace_attach</code>主要处理tracer刚刚附着到一个tracee的情况，主要处理一些标志位（<code>task_struct-&gt;ptrace</code>）等。而<code>arch_ptrace</code>主要处理附着之后的正常的<code>ptrace</code>命令，该函数可以看作是一个大的<code>switch</code>语句（在实际代码中，会层级式调用，这里展开成一个大的switch-case语句）：</p>
<figure class="highlight c"><figcaption><span>arch/x86/kernel/ptrace.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">arch_ptrace</span><span class="params">(<span class="keyword">struct</span> task_struct *child, <span class="keyword">long</span> request, </span></span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> data) &#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (request) &#123;</div><div class="line">    <span class="keyword">case</span> PTRACE_PEEKUSR:</div><div class="line">        ...</div><div class="line">    <span class="keyword">case</span> PTRACE_SETREGS:</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">    <span class="keyword">case</span> PTRACE_SYSCALL:</div><div class="line">        <span class="keyword">return</span> ptrace_resume(child, request, data);</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在<code>arch_ptrace</code>中具体处理了各种命令，这些命令可以查看/修改tracee进程的信息。因为在上面的例子中用到了<code>PTRACE_SYSCALL</code>，这里着重分析一下。</p>
<p><code>PTRACE_SYSCALL</code>调用了<code>ptrace_resume</code>函数，深入该函数，它设置了tracee的EFLAGS，设置了<code>TIF_SYSCALL_TRACE</code>位，并调用了<code>wake_up_state()</code>将tracee置为<code>__TASK_TRACED</code>状态并唤醒，让它继续执行。</p>
<p>从此，在tracee进行系统调用前，执行流程会执行如下代码调用相应的系统调用：</p>
<figure class="highlight"><figcaption><span>arch/x86/kernel/entry_32.S</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#define _TIF_SYSCALL_TRACE (1 &lt;&lt; TIF_SYSCALL_TRACE)</div><div class="line">#define _TIF_WORK_SYSCALL_ENTRY \</div><div class="line">    (_TIF_SYSCALL_TRACE | ...)</div><div class="line"></div><div class="line">ENTRY (system_call)</div><div class="line">    ...</div><div class="line">    testl $_TIF_WORK_SYSCALL_ENTRY, TI_FLAGS(%ebp)</div><div class="line">    jnz syscall_trace_entry</div><div class="line">    ...</div><div class="line"></div><div class="line">syscall_trace_entry:</div><div class="line">    ...</div><div class="line">    call syscall_trace_enter</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>执行流程首先会测试<code>TIF_SYSCALL_TRACE</code>是否被置位，若是，则最终会调用<code>syscall_trace_enter</code>，而后者最终会调用<code>ptrace_notify</code>向该进程发送一个<code>SIGTRAP</code>信号。此时，该信号就会被tracer拦截到，在tracer让tracee恢复执行期间，可以读取/修改tracee进程中的内容。</p>
<p>（以上）</p>
<p>注： 这里使用的内核代码为3.8版本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ptrace提供了一种让一个程序（tracer）控制另一个程序（tracee）执行流程，甚至时修改被控制程序内存或者寄存器的方法，ptrace的man手册这样描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The  ptrace()  system  call provides a means by which one&lt;br&gt;process (the “tracer”) may observe and control the execu‐&lt;br&gt;tion  of  another process (the “tracee”), and examine and&lt;br&gt;change the tracee’s memory and registers.  It is  primar‐&lt;br&gt;ily  used  to  implement  breakpoint debugging and system&lt;br&gt;call tracing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用户空间的每个进程，在内核中都有一个&lt;code&gt;task_struct&lt;/code&gt;结构与之对应
    
    </summary>
    
    
      <category term="Kernel" scheme="http://asxalex.pw/tags/Kernel/"/>
    
      <category term="Linux" scheme="http://asxalex.pw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>设备驱动程序的操作调用</title>
    <link href="http://asxalex.pw/2016/12/18/sys-open/"/>
    <id>http://asxalex.pw/2016/12/18/sys-open/</id>
    <published>2016-12-18T08:03:51.000Z</published>
    <updated>2017-02-03T07:02:32.243Z</updated>
    
    <content type="html"><![CDATA[<p>在编写设备驱动程序的时候，我们会编写一系列针对设备文件的操作方法，常见的有<code>open</code>, <code>release</code>, <code>llseek</code>, <code>read</code>, <code>write</code>等，这些操作都通过一个<code>file_operations</code>这个结构体被装载到特定的设备上。之后，这些函数都在等待特定事件的发生，在事件发生时会被调用，比如，当我们打开字符设备文件<code>/dev/mychardev</code>时，之前定义的<code>open</code>函数会被调用，之后对该文件的读写会相应地调用<code>read</code>和<code>write</code>。<a id="more"></a></p>
<h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><p>内核中相关的内核数据结构有<code>struct inode</code>，<code>struct dentry</code>，<code>struct file</code>和<code>struct file_operations</code>，他们的关系如下：</p>
<ul>
<li><code>inode</code>：是内核中对一个文件的表示；</li>
<li><code>file</code>：是内核中对一个打开的文件的表示，当一个文件被打开多次时，这个文件对应一个<code>inode</code>，而一般情况下会对应多个<code>file</code>结构；</li>
<li><code>dentry</code>：当同一个文件有不同文件名时，该文件会对应一个<code>inode</code>结构，而会对应多个<code>dentry</code>结构，该结构维护着目录项（路径）和<code>inode</code>的关系，即可以通过不同的<code>dentry</code>结构（不同路径下的同一个文件）找到同一个表示文件的<code>inode</code>；</li>
<li><code>file_operations</code>：是定义在文件身上的一些操作，当对文件进行操作时，这些操作被映射到<code>file_operations</code>结构中定义的函数上。</li>
</ul>
<h2 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h2><p>字符设备在内核中以<code>struct cdev</code>表示：</p>
<figure class="highlight c"><figcaption><span>include/linux/cdev.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> cdev &#123;</div><div class="line">    <span class="keyword">struct</span> kobject kobj;</div><div class="line">    <span class="keyword">struct</span> <span class="keyword">module</span> *owner;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *ops;</div><div class="line">    <span class="keyword">struct</span> list_head <span class="built_in">list</span>;</div><div class="line">    <span class="keyword">dev_t</span> dev;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>字符设备中包括了一组针对该设备文件的操作方法（<code>ops</code>成员），在编写字符设备驱动的时候使用<code>cdev_init</code>将实际用户定义的操作方法与字符设备绑定。</p>
<p>同时，在向系统注册字符设备的时候，系统会给新定义的字符设备分配（或者我们静态指定）设备号，该设备号用于系统中唯一标识我们的设备（以下用<code>devno</code>表示分配到的设备号）。</p>
<h2 id="创建字符设备文件"><a href="#创建字符设备文件" class="headerlink" title="创建字符设备文件"></a>创建字符设备文件</h2><p>创建字符设备文件是通过<code>mknod</code>命令实现的，该命令用于创建字符设备或块设备的特殊文件，它实际调用了<code>sys_mknod</code>的系统调用，而<code>sys_mknod</code>会根据所在文件系统的不同调用实际文件系统的<code>mknod</code>方法，比如<code>ext4</code>文件系统的方法名为<code>ext4_mknod</code>：</p>
<figure class="highlight c"><figcaption><span>fs/ext4/namei.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_mknod</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry,</span></span></div><div class="line">              <span class="keyword">int</span> mode, <span class="keyword">dev_t</span> rdev)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">struct</span> inode *inode;</div><div class="line">    <span class="keyword">int</span> err;</div><div class="line">    ...</div><div class="line"></div><div class="line">    inode = ext4_new_inode(handle, dir, mode, &amp;dentry-&gt;d_name, <span class="number">0</span>);</div><div class="line">    err = PTR_ERR(inode);</div><div class="line">    <span class="keyword">if</span> (!IS_ERR(inode)) &#123;</div><div class="line">        init_special_inode(inode, inode-&gt;i_mode, rdev);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数会调用<code>init_special_inode</code>函数：</p>
<figure class="highlight c"><figcaption><span>fs/inode.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_special_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> rdev)</span></span></div><div class="line">&#123;</div><div class="line">	inode-&gt;i_mode = mode;</div><div class="line">	<span class="keyword">if</span> (S_ISCHR(mode)) &#123;</div><div class="line">		inode-&gt;i_fop = &amp;def_chr_fops;</div><div class="line">		inode-&gt;i_rdev = rdev;</div><div class="line">	&#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数中判断，如果是字符设备，就将<code>inode</code>的<code>i_fop</code>和表示字符设备的<code>i_rdev</code>赋值：</p>
<figure class="highlight c"><figcaption><span>fs/char_dev.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> file_operations def_chr_fops = &#123;</div><div class="line">	.open = chrdev_open,</div><div class="line">	.llseek = noop_llseek,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> cdev *p;</div><div class="line">	<span class="keyword">struct</span> cdev *<span class="keyword">new</span> = <span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">	spin_lock(&amp;cdev_lock);</div><div class="line">	p = inode-&gt;i_cdev;</div><div class="line"></div><div class="line">	ret = -ENXIO;</div><div class="line">	filp-&gt;f_op = fops_get(p-&gt;ops);</div><div class="line">	<span class="keyword">if</span> (!filp-&gt;f_op)</div><div class="line">		<span class="keyword">goto</span> out_cdev_put;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (filp-&gt;f_op-&gt;open) &#123;</div><div class="line">		ret = filp-&gt;f_op-&gt;open(inode,filp);</div><div class="line">		<span class="keyword">if</span> (ret)</div><div class="line">			<span class="keyword">goto</span> out_cdev_put;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在字符设备默认的<code>chrdev_open</code>操作中将<code>inode</code>的字符设备的<code>ops</code>赋值给<code>file</code>结构的<code>f_ops</code>，所以，在第一次打开这个设备文件的时候，<code>chrdev_open</code>被调用，然后它用用户定义的<code>open</code>函数代理进行实际的打开操作，并且，将该<code>file</code>结构的<code>f_op</code>设置成用户定义的文件操作集，所以以后针对文件的操作都会使用用户定义的函数。</p>
<p>通过设置<code>filp</code>的值以及联合文件描述符<code>fd</code>，在之后的程序中，内核就可以通过<code>current</code>宏、<code>fdtable</code>文件描述符表得到之前设置的<code>file</code>结构，从而完成操作函数的自定义。</p>
<h2 id="打开设备文件"><a href="#打开设备文件" class="headerlink" title="打开设备文件"></a>打开设备文件</h2><p>当用户在用户空间调用<code>open</code>系统调用时，内核空间会调用<code>do_sys_open</code>函数，该函数的大致流程为：</p>
<ol>
<li>根据用户传输的打开模式，从系统中分配一个未被使用的文件描述符<code>fd</code>；</li>
<li>调用<code>do_filp_open</code>，从系统中新分配一个<code>file</code>结构；</li>
<li>调用<code>fd_install</code>将<code>fd</code>和<code>file</code>结构绑定；</li>
</ol>
<p>在<code>do_filp_open</code>函数中，顺着调用链走下去依次是：<code>path_openat</code> -&gt; <code>do_last</code> -&gt; <code>finish_open</code> -&gt; <code>do_dentry_open</code>，在<code>do_dentry_open</code>中实际调用了<code>inode</code>中的<code>i_fop</code>（在<code>fs/inode.c</code>中首先被初始化为<code>&amp;def_chr_fops</code>）:</p>
<figure class="highlight"><figcaption><span>fs/open.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static int do_dentry_open(struct file *f, </div><div class="line">        int(*open)(struct inode *, struct file*), </div><div class="line">        const struct cred *cred) &#123;</div><div class="line">	static const struct file_operations empty_fops = &#123;&#125;;</div><div class="line">	struct inode *inode;</div><div class="line">	int error;</div><div class="line">    ...</div><div class="line"></div><div class="line">	f-&gt;f_op = fops_get(inode-&gt;i_fop);</div><div class="line">    ...</div><div class="line">	if (!open &amp;&amp; f-&gt;f_op)</div><div class="line">		open = f-&gt;f_op-&gt;open;</div><div class="line">	if (open) &#123;</div><div class="line">		error = open(inode, f);</div><div class="line">		if (error)</div><div class="line">			goto cleanup_all;</div><div class="line">	&#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此，用户在设备驱动程序中定义的各种操作方法就能够被内核调用了:)</p>
<p>（以上）</p>
<p>注： 这里使用的内核代码为3.8版本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编写设备驱动程序的时候，我们会编写一系列针对设备文件的操作方法，常见的有&lt;code&gt;open&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt;, &lt;code&gt;llseek&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;等，这些操作都通过一个&lt;code&gt;file_operations&lt;/code&gt;这个结构体被装载到特定的设备上。之后，这些函数都在等待特定事件的发生，在事件发生时会被调用，比如，当我们打开字符设备文件&lt;code&gt;/dev/mychardev&lt;/code&gt;时，之前定义的&lt;code&gt;open&lt;/code&gt;函数会被调用，之后对该文件的读写会相应地调用&lt;code&gt;read&lt;/code&gt;和&lt;code&gt;write&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Fun" scheme="http://asxalex.pw/tags/Fun/"/>
    
      <category term="Kernel" scheme="http://asxalex.pw/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>“手工”分区调整</title>
    <link href="http://asxalex.pw/2016/11/27/partition_resize/"/>
    <id>http://asxalex.pw/2016/11/27/partition_resize/</id>
    <published>2016-11-27T10:24:48.000Z</published>
    <updated>2016-11-30T03:47:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作经常用到虚拟机里面的archlinux，当时虚拟机给分配的8G的硬盘空间，现硬盘容量告急，根分区使用了99%的容量，还剩不到100M，安装的时候也没有使用lvm管理，于是就想熟悉一下硬盘的结构，看看能不能手工修改某些参数，以扩大分区，满足日常使用。</p>
<p>首先将虚拟机的硬盘从8G扩大到了20G，硬盘的分区表存储在主引导扇区(硬盘第一个扇区)，主引导扇区有512字节<a id="more"></a>，经过查阅资料，得到MBR的结构如下：</p>
<p><img src="http://asxalex.qiniudn.com/mbr.png" alt="img"></p>
<p>前446字节是<code>bootloader</code>，暂不分析，之后是4个16字节的分区表，共64字节，最后是0x55aa，这边的重点是16字节的分区表。</p>
<p>此时，我的机器的硬盘情况如下：</p>
<p><img src="http://asxalex.qiniudn.com/fdisk_output.png" alt="img"></p>
<p>了解结构之后，使用如下结构体解析mbr，具体程序<a href="https://github.com/asxalex/mbr-parser" target="_blank" rel="external">在这里</a>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTOR_SIZE 512</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PROG_LENGTH 446</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MEGA_BYTES (1024*1024)</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _chs_s <span class="keyword">chs_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _parted_s <span class="keyword">partition_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _mbr_s <span class="keyword">mbr_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _chs_s &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> head;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sector:<span class="number">6</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cylinder:<span class="number">10</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _parted_s &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> active;</div><div class="line">    <span class="keyword">chs_t</span> start;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> type;</div><div class="line">    <span class="keyword">chs_t</span> end;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> start_sector;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sector_num;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _mbr_s &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> program[PROG_LENGTH];</div><div class="line">    <span class="keyword">partition_t</span> partition[<span class="number">4</span>];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> end_flag[<span class="number">2</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>解析结果如下：</p>
<p><img src="http://asxalex.qiniudn.com/chs_output.png" alt="img"></p>
<p>此时打印了三个分区表，第四个分区表是全0，用<code>fdisk</code>命令新建分区，使用全部的剩余空间，结果如下：</p>
<p><img src="http://asxalex.qiniudn.com/new_partition.png" alt="img"></p>
<p>由于在结构中，分区信息(主分区)完全存储在MBR中，所以想到：如果直接改写MBR的分区表会有啥结果，如果没有其他地方有检查的话，应该就是直接将分区扩大了，于是继续写程序，将第三个分区的<code>end_chs</code>改成第四个分区的<code>end_chs</code>，第三个分区的<code>sector_num</code>改写成第三第四两个<code>sector_num</code>的和，同时将第四个分区所有位都置零，具体程序还是在<a href="https://github.com/asxalex/mbr-parser" target="_blank" rel="external">这里</a></p>
<p>之后生成一个<code>result</code>文件，使用命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta"># dd <span class="meta-keyword">if</span>=result of=/dev/sda bs=512 count=1</span></div></pre></td></tr></table></figure>
<p>写入之后，再fdisk查看磁盘信息：</p>
<p><img src="http://asxalex.qiniudn.com/fdisk_output_new.png" alt="img"></p>
<p>fdisk读取到的磁盘信息没问题了，再使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># resize2fs /dev/sda3</div><div class="line"><span class="meta"># dd <span class="meta-keyword">if</span>=/dev/zero of=abc bs=128M count=50</span></div></pre></td></tr></table></figure>
<p>使<code>sda3</code>使用全部分区空间，同时测试一下，可以写成功，应该就没啥问题了。</p>
<p>(以上)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作经常用到虚拟机里面的archlinux，当时虚拟机给分配的8G的硬盘空间，现硬盘容量告急，根分区使用了99%的容量，还剩不到100M，安装的时候也没有使用lvm管理，于是就想熟悉一下硬盘的结构，看看能不能手工修改某些参数，以扩大分区，满足日常使用。&lt;/p&gt;
&lt;p&gt;首先将虚拟机的硬盘从8G扩大到了20G，硬盘的分区表存储在主引导扇区(硬盘第一个扇区)，主引导扇区有512字节
    
    </summary>
    
    
      <category term="Fun" scheme="http://asxalex.pw/tags/Fun/"/>
    
      <category term="Linux" scheme="http://asxalex.pw/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用c语言手写解释器</title>
    <link href="http://asxalex.pw/2016/09/20/compiler/"/>
    <id>http://asxalex.pw/2016/09/20/compiler/</id>
    <published>2016-09-20T00:50:41.000Z</published>
    <updated>2016-11-27T12:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>解释器名字叫TTtL:)，TTtL从词法分析，语法分析到语义分析均用c完成，实现了一些基本的解释器的功能，包括函数定义，文件引用以及基本的控制流程。具体实现和例子可以看<a href="https://github.com/asxalex/TTtL" target="_blank" rel="external">这里</a>。TTtL还处于玩具级别。以下是用TTtL写的打印前10个斐波那契数的程序：<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">define <span class="title">fib</span><span class="params">(n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</div><div class="line">        <span class="number">1</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fib(i))</div><div class="line">    i = i + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的例子可以看出语法跟c语言很类似，毕竟自己实现嘛，可以想怎样实现就怎样实现。</p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析的主要工作是扫描整个源文件，根据我们事先定义好的规则(词法规则)，将源文件识别为一系列的单词(token)，简单来说，这个过程就是：</p>
<ol>
<li>词法分析程序读入文件，从左到右扫描每个字符；</li>
<li>根据当前所读取的字符，初步判定该token的单词类型(可能会有不同的单词类型开头相同)；</li>
<li>读取下一个字符，逐步细分该单词类型，直到最后确定一个单词类型；</li>
<li>确定该单词类型之后，按照该单词类型的规则读取，直到某个字符不符合该单词类型的规则，此时一个单词读取完毕；</li>
<li>重复上面规则，直到源文件读取完毕。</li>
</ol>
<p>这里实现的方法比较简单，手工细分单词类型。另外会有基于状态机的词法分析方法，根据当前读取到的字符，配合状态转移表进行单词的读取。</p>
<p>在TTtL中，词法分析在<strong>lexer.c</strong>中，读取到的单词被存放到一个保存结构体的列表里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __lex lex;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __lex &#123;</div><div class="line">    <span class="keyword">char</span> *value; <span class="comment">// store the real value of the token</span></div><div class="line">    TOKEN token; <span class="comment">// indicate the token type, i.e. IDENTIFIER, NUMBER, etc.</span></div><div class="line">    <span class="keyword">int</span> line; <span class="comment">// show where the token is scanned.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在获取到这个列表之后就可以进行下一步操作了</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>在词法分析的基础上，语法分析接受词法分析结果，一个一个地读取词法分析的结果。具体在TTtL里面，使用<a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" rel="external">递归下降</a>的解析方法构造AST。定义了以下的ast类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> __ast_type ast_type;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> __ast_type &#123;</div><div class="line">    NUMBERAST,</div><div class="line">    VARIABLEAST,</div><div class="line">    BINARYAST,</div><div class="line">    CHARACTERAST,</div><div class="line">    STRINGAST,</div><div class="line">    IDENTIFIERAST,</div><div class="line">    CALLAST,</div><div class="line">    FUNCTIONAST,</div><div class="line">    IFAST,</div><div class="line">    WHILEAST,</div><div class="line">    BOOLEANAST,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中的BINARYAST用于包含二元运算符，用BINARYAST包含BINARYAST来表示二元运算符的优先级。解析完之后，输出一个包含ast的列表，供语义分析使用。</p>
<p>具体实现文件为<strong>parser.c</strong>。</p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语义分析是在抽象语法树的基础上对该语法树求值，得到最后的结果。具体来讲，针对不同的ast，进行不同的求值:</p>
<ul>
<li>当ast为BINARYAST时，首先对左右分支递归求值，然后将运算符运用到左右分支上求值；</li>
<li>当ast为自求值类型(字符串，数字，字符类型等)时不加处理，直接输出；</li>
<li>当ast为控制结构(if, while等)，就按逻辑求值；</li>
<li>…</li>
</ul>
<p>这里还有一个问题：在求值的时候会需要“上下文”，这个“上下文”主要保存一些变量的值，类似于c语言里面的栈帧，在进行函数调用的时候，这个上下文还得能够进行“切换”。TTtL在<strong>environment.c</strong>里面实现了这个环境，主要有新建环境(进入新的名字空间)，设置变量值，插入变量值等操作。</p>
<p>有了“环境”这个外在的支持，语义分析就可以进行了，当进入函数调用的时候，首先新建一个环境，并在新环境中将参数值插入里面，然后进行函数体的执行。当函数体定义一个变量时也插入到该环境中，当函数体需要某个变量的值的时候，就去环境里面找，若在当前环境里面找不到，就去外层环境找，若所有都找不到，则报错：使用未定义的变量</p>
<p>语义分析的具体实现在<strong>eval.c</strong>中。</p>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>main函数主要工作是打开源文件，然后将源文件“喂”给以上几个组件，然后获取eval的输出，得到最终运行结果。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>为了更完善，<a href="https://github.com/asxalex/TTtL" target="_blank" rel="external">git项目</a>里面还有一个<strong>vim-syntax</strong>目录，用于vim的语法着色，效果如下:)</p>
<p><img src="http://asxalex.qiniudn.com/vim-syntax.png" alt="img"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解释器名字叫TTtL:)，TTtL从词法分析，语法分析到语义分析均用c完成，实现了一些基本的解释器的功能，包括函数定义，文件引用以及基本的控制流程。具体实现和例子可以看&lt;a href=&quot;https://github.com/asxalex/TTtL&quot;&gt;这里&lt;/a&gt;。TTtL还处于玩具级别。以下是用TTtL写的打印前10个斐波那契数的程序：
    
    </summary>
    
    
      <category term="Fun" scheme="http://asxalex.pw/tags/Fun/"/>
    
      <category term="TTtL" scheme="http://asxalex.pw/tags/TTtL/"/>
    
  </entry>
  
  <entry>
    <title>C++对象在内存中的布局</title>
    <link href="http://asxalex.pw/2013/09/19/c-plus-plus-dui-xiang-nei-cun-bu-ju/"/>
    <id>http://asxalex.pw/2013/09/19/c-plus-plus-dui-xiang-nei-cun-bu-ju/</id>
    <published>2013-09-19T04:44:00.000Z</published>
    <updated>2016-11-14T09:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看c++对象模型，要理解c++对象模型，必须得了解c++对象在计算机内存中的布局情况。虚函数是c++中多态的基础，而多态是通过虚函数表来实现的。在每个拥有虚函数的对象中，都有一个vptr指向这个对象的虚函数表vtable。下面，我们就单继承与多继承两种情况来对c++对象在内存中的布局进行实验，用直观的方式来“打印”类对象在内存中的位置。需要说明的是：类对象在内存中的布局与操作系统以及编译器都有关系，所以在不同编译环境下打印结果可能不同。这个实验旨在让我更清晰地了解类对象在内存中的布局。</p>
<a id="more"></a>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>为了分析出单继承下类的布局，我们涉及了三个类：Father、Child以及GrandChild。正如名字一样，他们一代代继承下来。类图如下：</p>
<img src="http://asxalex.qiniudn.com/class1.png">
<p>在Father类中，我们定义了三个虚函数f()、g()和h()。在Child类中，我们覆写了Father类的f(),并添加了Child类自己的虚函数g_child()以及h_child()。在孙子类GrandChild中，父类Child的f()以及g_child()被覆写，另外又添加了自己的虚函数h_grandchild()以及非虚函数x()。</p>
<figure class="highlight c++"><figcaption><span>vtable.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Father&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">int</span> ifather;</div><div class="line">        Father():ifather(<span class="number">10</span>)&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Father::f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Father::g"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Father::h"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Child : <span class="keyword">public</span> Father&#123;</div><div class="line">        <span class="keyword">int</span> iChild;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Child():iChild(<span class="number">100</span>)&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g_child</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::g_child"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h_child</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child::h_child"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> GrandChild : <span class="keyword">public</span> Child&#123;</div><div class="line">        <span class="keyword">double</span> iGrandChild;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        GrandChild():iGrandChild(<span class="number">1000.1</span>)&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GrandChild::f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g_child</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GrandChild::g_child"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h_grandchild</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GrandChild::h_grandchild"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"GrandChild::x"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以下为打印虚函数表的代码：</p>
<figure class="highlight c++"><figcaption><span>vtable.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vtable.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> GrandChild::a = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunc)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">    GrandChild gc;</div><div class="line">    Child child;</div><div class="line">    Father father;</div><div class="line">    <span class="keyword">int</span> **pgc = (<span class="keyword">int</span> **)&amp;gc;</div><div class="line">    <span class="keyword">int</span> **pc = (<span class="keyword">int</span> **)&amp;child;</div><div class="line">    <span class="keyword">int</span> **pf = (<span class="keyword">int</span> **)&amp;father;</div><div class="line">    pFunc pfunc;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vtable of Grangchild is: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (pFunc)pgc[<span class="number">0</span>][i] != <span class="literal">NULL</span>; ++i)&#123;</div><div class="line">        pfunc = (pFunc)pgc[<span class="number">0</span>][i];</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" ["</span> &lt;&lt; i &lt;&lt; <span class="string">"] "</span>;</div><div class="line">        pfunc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vtable of Child is: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (pFunc)pc[<span class="number">0</span>][i] != <span class="literal">NULL</span>; ++i)&#123;</div><div class="line">        pfunc = (pFunc)pc[<span class="number">0</span>][i];</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" ["</span> &lt;&lt; i &lt;&lt; <span class="string">"] "</span>;</div><div class="line">        pfunc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vtable of Father is: "</span>&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</div><div class="line">        pfunc = (pFunc)pf[<span class="number">0</span>][i];</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" ["</span> &lt;&lt; i &lt;&lt; <span class="string">"] "</span>;</div><div class="line">        pfunc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size of GrandChild is "</span> &lt;&lt; <span class="keyword">sizeof</span>(gc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"iFather:"</span> &lt;&lt; (<span class="keyword">int</span>)pgc[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"iChild:"</span> &lt;&lt; (<span class="keyword">int</span>)pgc[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"iGrandChild:"</span> &lt;&lt; *(<span class="keyword">double</span>*)(<span class="keyword">void</span>*)&amp;pgc[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道大概的类布局。Vptr在对象开头，它指向一个Vtable，Vtable里面存着这个类通过继承、覆写、定义而得到的虚函数指针。紧接着Vptr便是我们在该类中定义的数据成员。类中的一般函数、static函数被转化为全局空间中的函数，并不存储在对象中。另外，类中的static数据成员也不存储在对象中。这个结论我们可以在以下的结果中看出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">vtable of Grangchild is: </div><div class="line">[<span class="number">0</span>] GrandChild::f</div><div class="line">[<span class="number">1</span>] Father::g</div><div class="line">[<span class="number">2</span>] Father::h</div><div class="line">[<span class="number">3</span>] GrandChild::g_child</div><div class="line">[<span class="number">4</span>] Child::h_child</div><div class="line">[<span class="number">5</span>] GrandChild::h_grandchild</div><div class="line"></div><div class="line">vtable of Child is: </div><div class="line">[<span class="number">0</span>] Child::f</div><div class="line">[<span class="number">1</span>] Father::g</div><div class="line">[<span class="number">2</span>] Father::h</div><div class="line">[<span class="number">3</span>] Child::g_child</div><div class="line">[<span class="number">4</span>] Child::h_child</div><div class="line"></div><div class="line">vtable of Father is: </div><div class="line">[<span class="number">0</span>] Father::f</div><div class="line">[<span class="number">1</span>] Father::g</div><div class="line">[<span class="number">2</span>] Father::h</div><div class="line">father's fourth element is <span class="number">1917268017</span></div><div class="line">size of GrandChild is <span class="number">20</span></div><div class="line">iFather:<span class="number">10</span></div><div class="line">iChild:<span class="number">100</span></div><div class="line">iGrandChild:<span class="number">1000.1</span></div></pre></td></tr></table></figure>
<p>通过以上结果，我们可以大致得到下面的内存布局图：</p>
<img src="http://asxalex.qiniudn.com/class2.png">
<p>由于GrandChild的大小为20（4（Vptr）+ 4（int）+ 4（int）+ 8（double））。所以静态数据成员以及一般成员函数均没有存储在对象的内存空间中。再次对GrandChild的布局进行探究，可以发现是以下的投影叠加版本：</p>
<img src="http://asxalex.qiniudn.com/class3.png">
<p>另外需要说明的是：Father的虚函数表里面最后一个似乎并不是NULL。打印出来是一个非常大的数（1917268017）。所以，在打印Father的虚函数表的时候用的条件不是判断NULL，而是通过i的计数来实现的。</p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>同样，利用上面的方法，我们来看一下多继承下的内存布局，先看类图：</p>
<img src="http://asxalex.qiniudn.com/class4.png">
<p>代码如下：</p>
<figure class="highlight c++"><figcaption><span>vtable2.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ONE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> THREE 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR 7</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Base1&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">int</span> base1;</div><div class="line">        <span class="keyword">int</span> base11;</div><div class="line">        Base1():base1(<span class="number">10</span>),base11(<span class="number">9</span>)&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::g"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::h"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base2&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">int</span> base2;</div><div class="line">        Base2():base2(<span class="number">11</span>)&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::g"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::h"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base3&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">int</span> base3;</div><div class="line">        Base3():base3(<span class="number">12</span>)&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::g"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base3::h"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">double</span> derived;</div><div class="line">        Derived():derived(<span class="number">12.34</span>)&#123;&#125;;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::g1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFunc)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">    pFunc pfunc = <span class="literal">NULL</span>;</div><div class="line">    Derived derived;</div><div class="line">    <span class="keyword">int</span> **pd = (<span class="keyword">int</span> **)&amp;derived;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vtable of derived is :"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\t'</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</div><div class="line">        pfunc = (pFunc)pd[ONE][i];</div><div class="line">        pfunc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"attention! "</span>&lt;&lt; pd[ONE][<span class="number">4</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base1: "</span> &lt;&lt; (<span class="keyword">int</span>)pd[ONE + <span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base11: "</span> &lt;&lt; (<span class="keyword">int</span>)pd[ONE + <span class="number">2</span>] &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\t'</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</div><div class="line">        pfunc = (pFunc)pd[TWO][i];</div><div class="line">        pfunc();</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"attention! "</span>&lt;&lt; pd[TWO][<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base2: "</span> &lt;&lt; (<span class="keyword">int</span>)pd[TWO + <span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\t'</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; i &lt;&lt; <span class="string">"]"</span>;</div><div class="line">        pfunc = (pFunc)pd[THREE][i];</div><div class="line">        pfunc();</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"attention! "</span>&lt;&lt; pd[THREE][<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"base3: "</span> &lt;&lt; (<span class="keyword">int</span>)pd[THREE + <span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived: "</span> &lt;&lt; *(<span class="keyword">double</span>*)(<span class="keyword">void</span>*)&amp;pd[FOUR] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行后的结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">vtable of derived is :</div><div class="line">    [<span class="number">0</span>]Derived::f</div><div class="line">    [<span class="number">1</span>]Base1::g</div><div class="line">    [<span class="number">2</span>]Base1::h</div><div class="line">    [<span class="number">3</span>]Derived::g1</div><div class="line">attention! <span class="number">-12</span></div><div class="line">base1: <span class="number">10</span></div><div class="line">base11: <span class="number">9</span></div><div class="line">    [<span class="number">0</span>]Derived::f</div><div class="line">    [<span class="number">1</span>]Base2::g</div><div class="line">    [<span class="number">2</span>]Base2::h</div><div class="line">attention! <span class="number">-20</span></div><div class="line">base2: <span class="number">11</span></div><div class="line">    [<span class="number">0</span>]Derived::f</div><div class="line">    [<span class="number">1</span>]Base3::g</div><div class="line">    [<span class="number">2</span>]Base3::h</div><div class="line">attention! <span class="number">0</span></div><div class="line">base3: <span class="number">12</span></div><div class="line">derived: <span class="number">12.34</span></div></pre></td></tr></table></figure>
<p>看一下下面的图就明白整个布局啦:)</p>
<img src="http://asxalex.qiniudn.com/class5.png">
<p>值得先说明的是：我们的代码首先是检查Vtable项是否为NULL来判断是否到Vtable末尾项了，但这样运行后直接core dump了。所以，我们首先分析了某个Vtable有几项，然后通过计数来调用相应方法。在Vtable的最后，我们利用上面打印结果的attention！来打印相应的最后一项的内容。经观察这个数值可能是下一个Vtable距离对象开头的字节数。本来还想通过修改这个数值来验证这个想法，但好像那个空间没有写权限，又直接core dump了-_-!</p>
<p>从图上可以看出：  </p>
<blockquote>
<p>派生类的所有没有覆写父类的虚函数都“存放”在第一个父类的Vtable中；<br>派生类覆写的父类的虚函数会被“更新”到每个父类的Vtable中；<br>派生类中有多个Vtable及数据成员，他们的次序按照继承顺序排列。 </p>
</blockquote>
<p>注：以上程序运行环境为ubuntu12.04 3.2.0-53-generic-pae内核 + gcc 4.6.3</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看c++对象模型，要理解c++对象模型，必须得了解c++对象在计算机内存中的布局情况。虚函数是c++中多态的基础，而多态是通过虚函数表来实现的。在每个拥有虚函数的对象中，都有一个vptr指向这个对象的虚函数表vtable。下面，我们就单继承与多继承两种情况来对c++对象在内存中的布局进行实验，用直观的方式来“打印”类对象在内存中的位置。需要说明的是：类对象在内存中的布局与操作系统以及编译器都有关系，所以在不同编译环境下打印结果可能不同。这个实验旨在让我更清晰地了解类对象在内存中的布局。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="http://asxalex.pw/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>RAII与资源管理</title>
    <link href="http://asxalex.pw/2013/09/11/raiiyu-zi-yuan-guan-li/"/>
    <id>http://asxalex.pw/2013/09/11/raiiyu-zi-yuan-guan-li/</id>
    <published>2013-09-11T12:50:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>RAII（Resource Acquirsition Is Initialization），资源获得即初始化，是一种管理资源的极好的方法。这个术语的意思：在对象的初始化中包含它所要管理的资源的获取操作，而在该对象被析构时，被管理资源的释放动作会被执行（RRID，Resource Release Is Destruction）。</p>
<p>这里的资源是一个广义的概念：它可以是动态分配的堆空间，或是一个文件的句柄，抑或是一个经过抽象的打印机……这些资源的一个共同点是：当我们不再需要这个资源时，得对它进行释放操作。一旦客户忘记释放操作（我们可能会在不知不觉中忘记这个操作，比如说，在if语句中，我们调用了delete将动态分配的空间进行了释放，但在else中忘了释放……）将会导致资源泄漏，这对于一个运行几百毫秒的程序可能没什么大的影响，但对于一个要常年运行的服务器来说却是不可忍受的，一个小小的有资源泄漏的代码块执行成千上万次，所泄漏的资源就不能忽略不计了。<a id="more"></a></p>
<p>RAII这个术语不管是概念还是实现都是比较简单的，先看一个简单的栗子：</p>
<figure class="highlight c++"><figcaption><span>raii.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> RAII&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        RAII(T* a):pointee(a)&#123;&#125;</div><div class="line">        ~RAII()&#123;</div><div class="line">            <span class="keyword">delete</span> pointee;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deleted!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </div><div class="line">        &#125;</div><div class="line">        T* <span class="keyword">operator</span>-&gt;()&#123;</div><div class="line">            <span class="keyword">return</span> pointee;</div><div class="line">        &#125;</div><div class="line">        T&amp; <span class="keyword">operator</span>*()&#123;</div><div class="line">            <span class="keyword">return</span> *pointee;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T* pointee;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> mytype&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"in mytype"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>raii.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"raii.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    &#123;</div><div class="line">    RAII&lt;mytype&gt; a(<span class="keyword">new</span> mytype()); </div><div class="line">    a-&gt;show();</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们需要一个mytype资源时，我们初始化了一个对象a，在a的成员初值列中获取资源，由于a是一个栈变量，一旦超出作用域它就会被析构。于是我们在它的析构函数中进行资源的释放操作，这样，我们就不用再手动去释放资源了。</p>
<p>再看看下面的更实际一点的栗子（这个栗子是根据《Imperfect C++》中的栗子而”捏造“的）：</p>
<figure class="highlight c++"><figcaption><span>check.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Check&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T&amp; t)</span></span>&#123;</div><div class="line">            Checkin(t);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Out</span><span class="params">(T&amp; t)</span></span>&#123;</div><div class="line">            Checkout(t);</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C = Check&lt;T&gt; &gt;</div><div class="line"><span class="keyword">class</span> RAII&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        RAII(T* pass):ref(pass)&#123;</div><div class="line">            C::In(*ref);</div><div class="line">        &#125;</div><div class="line">        ~RAII()&#123;</div><div class="line">            C::Out(*ref);</div><div class="line">            <span class="keyword">delete</span> ref;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T* ref;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str):name(str)&#123;&#125;</div><div class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkin</span><span class="params">(Person&amp;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkout</span><span class="params">(Person&amp;)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>check.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"check.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkin</span><span class="params">(Person&amp; per)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; per.getName() &lt;&lt; <span class="string">" just checked in."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkout</span><span class="params">(Person&amp; per)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; per.getName() &lt;&lt; <span class="string">" just checked out."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    &#123;</div><div class="line">        RAII&lt;Person&gt; a(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"asxalex"</span>));</div><div class="line">        <span class="comment">/*</span></div><div class="line">            do the things</div><div class="line">        */</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我的栗子模拟一个同学们到机房的上机时的刷卡过程：当同学们进去时要In，出去时要Out（我恨透了这个系统，想起以前大一到大三上机时一旦忘了带卡，那个看门的大爷就会叫我回去拿，唉……）。这里，我们定义了一个外覆类Check，它调用被管理的资源类的相关函数，这样可以降低资源管理类与资源类之间的耦合，为了如此，我们为Person资源类定义了Checkin()和Checkout()两个函数，当管理不同资源时可以堆这两个函数进行重载。外覆类被当作资源管理模板类的第二个默认模板参数传入，在资源管理类中调用它里面的静态方法。当RAII对象的生存期结束时，它会调用外覆类中用于清理资源的另一个静态方法。</p>
<p>当我们在机房里开心地上机时，可能接到一个电话，我们就要出去接电话。这时候，我们就得先Checkout，之后，再Checkin。当然，代码可以像下面那样写：</p>
<figure class="highlight c++"><figcaption><span>check.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    &#123;</div><div class="line">        RAII&lt;Person&gt; a(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"asxalex"</span>));</div><div class="line">    &#125;<span class="comment">//这里，我出去接个电话</span></div><div class="line">    </div><div class="line">    <span class="comment">//开心地打电话中。。。</span></div><div class="line">    <span class="comment">//。。。</span></div><div class="line">    <span class="comment">//打完了电话</span></div><div class="line"></div><div class="line">    &#123;<span class="comment">//我又回来啦</span></div><div class="line">        RAII&lt;Person&gt; a(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"asxalex"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，当我们进出一次，我们就得构造一个Person（资源），析构这个资源。这样显然比较浪费。为此，我们写了以下代码：</p>
<figure class="highlight c++"><figcaption><span>check.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Check&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T&amp; t)</span></span>&#123;</div><div class="line">            Checkin(t);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Out</span><span class="params">(T&amp; t)</span></span>&#123;</div><div class="line">            Checkout(t);</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Uncheck&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">In</span><span class="params">(T&amp; t)</span></span>&#123;</div><div class="line">            Checkout(t);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Out</span><span class="params">(T&amp; t)</span></span>&#123;</div><div class="line">            Checkin(t);</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C = Check&lt;T&gt; &gt;</div><div class="line"><span class="keyword">class</span> RAII&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        RAII(T* pass):ref(pass)&#123;</div><div class="line">            C::In(*ref);</div><div class="line">        &#125;</div><div class="line">        ~RAII()&#123;</div><div class="line">            C::Out(*ref);</div><div class="line">            <span class="keyword">delete</span> ref;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T* ref;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> RAII&lt;T,Uncheck&lt;T&gt; &gt;&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        RAII(T* pass):ref(pass)&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"again :"</span>;</div><div class="line">            Uncheck&lt;T&gt;::In(*ref);</div><div class="line">        &#125;</div><div class="line">        ~RAII()&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"again :"</span>;</div><div class="line">            Uncheck&lt;T&gt;::Out(*ref);</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T* ref;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str):name(str)&#123;&#125;</div><div class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkin</span><span class="params">(Person&amp;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkout</span><span class="params">(Person&amp;)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>check.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"check.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkin</span><span class="params">(Person&amp; per)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; per.getName() &lt;&lt; <span class="string">" just checked in."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Checkout</span><span class="params">(Person&amp; per)</span></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; per.getName() &lt;&lt; <span class="string">" just checked out."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    &#123;</div><div class="line">        Person* alex = <span class="keyword">new</span> Person(<span class="string">"asxalex"</span>); </div><div class="line">        RAII&lt;Person&gt; a(alex);</div><div class="line">        </div><div class="line">        &#123;<span class="comment">//同样，出去接电话</span></div><div class="line">            RAII&lt;Person,Uncheck&lt;Person&gt; &gt; b(alex);</div><div class="line">         <span class="comment">//。。。</span></div><div class="line">        &#125;<span class="comment">//电话打完，继续进来上机</span></div><div class="line"></div><div class="line">    &#125;<span class="comment">//几天上机结束，同学们各回各家~</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"end."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码相较于第一版的模型来说更加”环保“：当我们需要出去接电话的时候，不需要销毁以前构造的Person资源，无论你出去多少次，都只需要一个构造/析构开销。为了达到这个目标，我们又写了一个Uncheck类，这个类只是Check的”取反“：当我们出去时作为In，进来时作为Out！同时，为了可以”共享“那个Person资源，我们对RAII模板类进行了特化:当用Uncheck作为第二个模板参数时无需delete掉那个Person资源。</p>
<p>顺便说一句，严格来说，上面的check.cpp并不算是RAII，而是RRID，在alex这个对象被构造出来时并没有Is Initialization ~</p>
<p>（EOF）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RAII（Resource Acquirsition Is Initialization），资源获得即初始化，是一种管理资源的极好的方法。这个术语的意思：在对象的初始化中包含它所要管理的资源的获取操作，而在该对象被析构时，被管理资源的释放动作会被执行（RRID，Resource Release Is Destruction）。&lt;/p&gt;
&lt;p&gt;这里的资源是一个广义的概念：它可以是动态分配的堆空间，或是一个文件的句柄，抑或是一个经过抽象的打印机……这些资源的一个共同点是：当我们不再需要这个资源时，得对它进行释放操作。一旦客户忘记释放操作（我们可能会在不知不觉中忘记这个操作，比如说，在if语句中，我们调用了delete将动态分配的空间进行了释放，但在else中忘了释放……）将会导致资源泄漏，这对于一个运行几百毫秒的程序可能没什么大的影响，但对于一个要常年运行的服务器来说却是不可忍受的，一个小小的有资源泄漏的代码块执行成千上万次，所泄漏的资源就不能忽略不计了。
    
    </summary>
    
    
      <category term="cpp" scheme="http://asxalex.pw/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译vim7.4</title>
    <link href="http://asxalex.pw/2013/09/08/jiao-cha-bian-yi-vim7-dot-4/"/>
    <id>http://asxalex.pw/2013/09/08/jiao-cha-bian-yi-vim7-dot-4/</id>
    <published>2013-09-08T10:09:00.000Z</published>
    <updated>2016-11-14T09:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>vim，作为编辑器之神，相信每一个接触过linux的人都很熟悉（至少听说过）。大概一个月前，vim发布了最新版vim7.4。作为vim的忠实用户，当然要下载下来体验一下喽。正好这几天正在玩RPi，所以，趁着这个机会，顺便学习一下交叉编译软件，以下是我在ubuntu12.04下交叉编译vim7.4的过程。</p>
<p>准备工作：安装之前的准备工作没什么好说的，至少要得到源代码吧？在下载完vim7.4之后（随便google一下就能搜到下载源代码的方法），由于vim还依赖libncurses.so这个动态链接库，所以也要下载ncurses-5.9.tar.gz（ftp下载：ftp.keystealth.org , 在pub/gnu/ncurses目录下）。<a id="more"></a></p>
<h2 id="移植ncurses-5-9"><a href="#移植ncurses-5-9" class="headerlink" title="移植ncurses-5.9"></a>移植ncurses-5.9</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ tar -xzvf ncurses<span class="number">-5.9</span>.tar.gz</div><div class="line">$ cd ncurses<span class="number">-5.9</span></div><div class="line">$ ./configure CC=arm-linux-gcc\</div><div class="line">                 --host=arm-linux\</div><div class="line">                 --target=arm-linux \</div><div class="line">                 --build=i686-linux\</div><div class="line">                 --with-shared</div></pre></td></tr></table></figure>
<p>但这样会在编译时提示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">undefined reference to `__gxx_personality_v0'</div><div class="line">...</div></pre></td></tr></table></figure>
<p>解决办法是配置时用arm-linux-g++代替arm-linux-gcc，之后是make HOSTCC=gcc CXX=arm-linux-gcc &amp;&amp; sudo make install。之后，在其lib目录下就有libncurses.so等动态链接库了。</p>
<h2 id="移植vim7-4"><a href="#移植vim7-4" class="headerlink" title="移植vim7.4"></a>移植vim7.4</h2><p>我在刚开始配置vim7.4的时候，运行configure的时候就是有问题。后来，在通过一番google之后，终于找到了这个—— <a href="https://vim.googlecode.com/hg/src/INSTALLx.txt" target="_blank" rel="external">INSTALLx.txt-cross-compiling Vim on Unix</a>。里面有vim交叉编译的参数，在经历过一次次Trial and error之后，有了以下的配置参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">./configure --host=arm-linux\</div><div class="line">                   --target=arm-linux\</div><div class="line">                   CC=arm-linux-gcc\</div><div class="line">                   --build=i686-linux\</div><div class="line">                   --with-tlib=ncurses\</div><div class="line">                   vim_cv_toupper_broken=yes\</div><div class="line">                   CPPFLAGS=-I/home/alex/Downloads/ncurses<span class="number">-5.9</span>/includencursesw\</div><div class="line">                   LDFLAGS=-L/home/alex/Downloads/ncurses<span class="number">-5.9</span>/lib/\</div><div class="line">                   --without-x --disable-gui\</div><div class="line">                   vim_cv_terminfo=yes\</div><div class="line">                   vim_cv_tty_group=world\</div><div class="line">                   vim_cv_getcwd_broken=yes\</div><div class="line">                   vim_cv_stat_ignores_slash=yes\</div><div class="line">                   vim_cv_memmove_handles_overlap=yes\</div><div class="line">                   --prefix=/usr/tools</div></pre></td></tr></table></figure>
<p>因为我在用raspberry pi时一般都是ssh上去的，也不需要GUI，所以使用了参数： –without-x –disable-gui；用–prefix指定生成的库文件的安装目录；另外的vim**都在INSTALLx.txt里有所说明。</p>
<p>在这之后，便是编译了，在这里我也遇到了困难：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ make CC=arm-linux-gcc</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<p>在进行make的时候还是挺顺利的，经过一段时间的等候就编译完了。倒是在最后一步理所当然要成功的make install出现了错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Starting make in the src directory.</div><div class="line">If there are problems, cd to the src directory and run make there</div><div class="line">cd src &amp;&amp; make install</div><div class="line">make[<span class="number">1</span>]: Entering directory `/home/alex/Downloads/vim74/src'</div><div class="line"><span class="keyword">if</span> test -f /usr/tools/bin/vim; then \</div><div class="line">      mv -f /usr/tools/bin/vim /usr/tools/bin/vim.rm; \</div><div class="line">      rm -f /usr/tools/bin/vim.rm; \</div><div class="line">    fi</div><div class="line">cp vim /usr/tools/bin</div><div class="line">strip /usr/tools/bin/vim</div><div class="line">strip: Unable to recognise the format of the input file `/usr/tools/bin/vim'</div><div class="line">make[<span class="number">1</span>]: *** [installvimbin] Error <span class="number">1</span></div><div class="line">make[<span class="number">1</span>]: Leaving directory `/home/alex/Downloads/vim74/src'</div><div class="line">make: *** [install] Error <span class="number">2</span></div></pre></td></tr></table></figure>
<p>这是make install有个参数STRIP，用于指定对文件进行strip操作的工具，由于我们是交叉编译，所以，“正常”的strip理所当然无法识别我们的文件，需要指定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo make STRIP=arm-linux-gnueabihf-strip install</div></pre></td></tr></table></figure>
<p>经过以上几步，在我们的host中的/usr/tools/目录下就有交叉编译的产物了，将它拷贝至raspberry pi中。另外，将libncurses.so.5.8拷贝到RPi的/usr/lib目录下，并作个软链接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ scp -r /usr/tools/ pi@<span class="number">192.168</span><span class="number">.2</span><span class="number">.14</span>:/usr/tools</div><div class="line">$ scp libncurses.so<span class="number">.5</span><span class="number">.8</span> pi@<span class="number">192.168</span><span class="number">.2</span><span class="number">.14</span>:/usr/lib</div><div class="line">#以上一步用于拷贝，实际操作中由于权限问题无法实现，须先拷贝至/home/pi/下，然后在拷贝到/usr/tools</div><div class="line"></div><div class="line"><span class="meta">#ssh pi@192.168.2.14</span></div><div class="line">$ sudo ln -s libncurses.so<span class="number">.5</span><span class="number">.8</span> libncurses.so<span class="number">.5</span></div><div class="line">$ sudo ln -s libncurses.so<span class="number">.5</span> libncurses.so</div></pre></td></tr></table></figure>
<p>最后，ssh到RPi上，执行以下命令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo rm /usr/bin/vim</div><div class="line">$ sudo ln -s /usr/tools/bin/vim /usr/bin/vim</div></pre></td></tr></table></figure>
<p>这样就完全大功告成啦:-)，执行一下vim –version，结果如下：</p>
<img src="http://asxalex.qiniudn.com/crosscompile.png">
<p>（EOF）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim，作为编辑器之神，相信每一个接触过linux的人都很熟悉（至少听说过）。大概一个月前，vim发布了最新版vim7.4。作为vim的忠实用户，当然要下载下来体验一下喽。正好这几天正在玩RPi，所以，趁着这个机会，顺便学习一下交叉编译软件，以下是我在ubuntu12.04下交叉编译vim7.4的过程。&lt;/p&gt;
&lt;p&gt;准备工作：安装之前的准备工作没什么好说的，至少要得到源代码吧？在下载完vim7.4之后（随便google一下就能搜到下载源代码的方法），由于vim还依赖libncurses.so这个动态链接库，所以也要下载ncurses-5.9.tar.gz（ftp下载：ftp.keystealth.org , 在pub/gnu/ncurses目录下）。
    
    </summary>
    
    
      <category term="Fun" scheme="http://asxalex.pw/tags/Fun/"/>
    
  </entry>
  
  <entry>
    <title>RPi图片抓拍</title>
    <link href="http://asxalex.pw/2013/09/05/rpijian-kong/"/>
    <id>http://asxalex.pw/2013/09/05/rpijian-kong/</id>
    <published>2013-09-05T15:33:00.000Z</published>
    <updated>2016-11-19T14:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>用这个名字是因为我也不知道该怎么叫它。说白了，就是利用一个RPi，以一定频率拍个照，然后上传到七牛云存储空间，利用它的外链功能来使这个博客里引用的图片<strong>假实时</strong>刷新，就是这样，喵～</p>
<p>原理上很简单，但真正实际做时还是碰到了一些困难。</p>
<p>RPi有个ethernet接口，但校园网下想要用起来还是有点困难（虽然不是不可能）。于是索性搞了个无线网卡（<a href="/2013/08/26/raspberrypi/">看这里</a>）,并ssh到RPi上，所以也没那么多线，就插了个usb无线网卡和一个usb摄像头，看起来清爽多了:-)<a id="more"></a>首先看一下实物图：</p>
<img src="http://asxalex.qiniudn.com/raspberry.png">
<p>在说明实现的曲折过程之前，我们先看看拍到的效果：</p>
<p><img id="test"></p>
<script language="javascript" type="text/javascript">

var mytime = new Date();
var minu = mytime.getMinutes();
var theURL = "http://asxalex.qiniudn.com/RPi";
var firstURL = theURL + minu%30 + ".jpg";
var backURL = theURL + minu%30 + ".back.jpg";

tagImg = document.getElementById("test");
tagImg.src=firstURL;
tagImg.onerror=function(){tagImg.src=backURL;}

</script>

<h2 id="第一次“实现”"><a href="#第一次“实现”" class="headerlink" title="第一次“实现”"></a>第一次“实现”</h2><p>在有了这个设想以后，很直接，用<a href="http://asxalex.tk/blog/2013/09/03/crontab/" target="_blank" rel="external">crontab</a>，搭配shell脚本以及七牛好用的python SDK，我很快就实现了以上提到的功能。刚实验成功时，我马上叫舍友来我的博客试试，并且得意地告诉他们：这个图片每隔一分钟会自动刷新！舍友当时很好奇，在过了一分钟之后，我给他按了个F5，页面是刷新了，可图一点没变，连图片上面加的time-stamp都没变。这是咋地啦？</p>
<h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h2><p>为什么会没变呢？我第一反应是浏览器的缓存，于是特地在我电脑上装了个chromium-browser（用习惯了firefox），结果非但没有如我所料（可以加载最新的图片），反而更加恶化，它竟然显示了比firefox还早的图片！看来不是浏览器的缓存问题，而是在源头：七牛云存储的缓存！</p>
<h2 id="第二次“实现”"><a href="#第二次“实现”" class="headerlink" title="第二次“实现”"></a>第二次“实现”</h2><p>由于问题是不能得到实时的图片，所以问题十有八九出在缓存身上。我用网页登录到七牛空间，尝试了下用firefox下载刚刚那个图片。图片上的time-stamp是正确的。于是想到可能图片在下载时会清除一下缓存。我马上在那个shell脚本里加了两句wget，继续尝试刚开始结果还好，过了几分钟又回到了老样子，唉～～<br>反正问题出在缓存身上，我等一段时间让它缓存过期不就行了？于是设置crontab为5分钟，还是会有不能实时更新的问题，我索性加到了20分钟，这下终于正常了。虽然问题似乎解决了，但还是不爽快。</p>
<h2 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h2><p>当时快凌晨两点了吧，通过google，我通过google，终于找到了一个七牛API，它里面介绍了一个清除缓存的方法。我马上又有精神了，用了一些linux下好用的工具软件，实现了在命令行下查看buckets（七牛中的对空间的称谓）。对七牛缓存的刷新只有一步之遥，但这一步比较艰辛。奋斗到凌晨三点，返回的结果还是“error： bad token” :-(<br>终于，还是洗洗睡了。<br>今天早上，我早早地起了床（早上10点左右），继续昨天没完成的事。进行了各种尝试，但还是那几个字：“error： bad token”。无奈之下，咨询了一下七牛的工程师，在进行了一些交流之后得知：由于CDN缓存等一些技术性原因，即使清除了七牛的缓存还是没用（可能在离我较近的服务器上的缓存还是没有得到更新，于是还是可能会出现上面的情况）。但七牛的工程师提示了一下：试试js。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以前写markdown，几乎全都是码字，很少会写标签，更加没试过在markdown中使用\&lt; script > 标签。由于个人对前端不怎么感冒，html、css、js等都是以前看过几天，但发现没什么兴趣，也没往深里看。<br>书到用时方恨少，我今天才体会到这句话的意思。下午我吃完饭就直接去图书馆，里面有很多关于js的书籍，但实在静不下心来看（知识需要平时的积累，临时抱佛脚是如果可以静下心来还可以，静不下心来根本什么都看不下去）。于是又到了求助谷大歌的时刻了。<br>一些技术性方面的知识在google中很容易就能找到，但这个要采取什么方案使用这些技术又得靠自己了。<br>起初，也是我和七牛工程师都想到的：用时间作为图片名。粗略估算一下：七牛提供10G免费空间，一张图片尺寸比较小，大约40K，大概可以用183天（10G/40K/60/24），期间固然可以在写一个crontab，每隔几天删除一次。但还是有一个致命的不足：时间同步。就算精确到1分钟，还是有可能在用户请求这个图片的时候，这张图片还没生成！另一个严重的问题是：我还在学校，晚上还是会断电，那时RPi就不能进行工作了，难道在RPi不能工作时图片区域就让它空白吗？</p>
<p>之后，一个解决办法是：用分钟来对图片命名。早先试过，在20分钟时间里可以确保缓存失效，于是利用分钟数对30取模来命名图片，比如现在：凌晨01：07，图片就命名为RPi7.jpg，当时间为01：37的时候首先将这张图片删除，然后上传这个时候拍的，这样RPix.jpg对于x取0～29均会有图片，如果RPi不能工作了，就让以前拍的照顶一下。<br>这个方法看似完美，但也有一个大问题：假设七牛的缓存每15分钟刷新一次，现在是01：00，到01：15时，缓存就会失效。这个时候是关键：这个缓存系统在这个缓存失效时会不会主动再要求一份，还是会在用户下次访问这个文件时才会再次缓存。我没有实验过，不知道真实情况是怎么样的，估计是后者。但万一是前者，我们这里的情况并不比以前的要好，用户还是会访问到以前的图片，即使刚刚删除和上传，只是少用了一些空间而已。</p>
<p>再然后，要解决这个问题，还是得在缓存上花心思，而且必须在所请求的那张图片还没生成（时间差）或者在所请求图片根本不会生成（RPi下线了）的时候有一张backup的图片。如果所请求图片加载失败，就让backup顶上:-)</p>
<p>说到backup，解决方案就来了：我们在每一分钟的开头会执行脚本，生成此刻的图片，上传到七牛。如果此时七牛上没有这个图片，在访问时就不会被缓存的问题困扰了。对，就是这样：当我们在一分钟的开头上传图片之后，此时在七牛空间中只有RPixx.back.jpg，之后，我们马上清除RPixx.back.jpg，同时，将它前一分钟的RPixx-1.jpg改名，成为RPixx-1.back.jpg。按照这个规则，在下一分钟的开头，我们的脚本就会将这一分钟上传的RPixx.jpg改名为RPixx.back.jpg。这样，我们悄悄地来，悄悄地走，没有带走一片云彩，只留下那一分钟里用户看到的刚拍的“新鲜”的图片:)</p>
<p>看一下下面的图你就全都明白啦～</p>
<img src="http://asxalex.qiniudn.com/script.png">
<p>By the way，其实我不知道这个可以用来拍什么，也没有实际活的宠物什么的，以后什么时候逛集市的时候给自己买个小乌龟或者小金鱼啥的。ps.我也接受任何人慈善地“捐助”一个哦:-)</p>
<p>（EOF）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用这个名字是因为我也不知道该怎么叫它。说白了，就是利用一个RPi，以一定频率拍个照，然后上传到七牛云存储空间，利用它的外链功能来使这个博客里引用的图片&lt;strong&gt;假实时&lt;/strong&gt;刷新，就是这样，喵～&lt;/p&gt;
&lt;p&gt;原理上很简单，但真正实际做时还是碰到了一些困难。&lt;/p&gt;
&lt;p&gt;RPi有个ethernet接口，但校园网下想要用起来还是有点困难（虽然不是不可能）。于是索性搞了个无线网卡（&lt;a href=&quot;/2013/08/26/raspberrypi/&quot;&gt;看这里&lt;/a&gt;）,并ssh到RPi上，所以也没那么多线，就插了个usb无线网卡和一个usb摄像头，看起来清爽多了:-)
    
    </summary>
    
    
      <category term="Fun" scheme="http://asxalex.pw/tags/Fun/"/>
    
  </entry>
  
  <entry>
    <title>crontab</title>
    <link href="http://asxalex.pw/2013/09/03/crontab/"/>
    <id>http://asxalex.pw/2013/09/03/crontab/</id>
    <published>2013-09-03T05:15:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在linux下面有许许多多有用的工具，能够极大解放生产力。crontab就是其中的一个工具软件。</p>
<p>crontab用于在一定的时间间隔调度一些命令的执行（以一定的频率执行用户事先确定好的命令，脚本等）。系统有一个/etc/crontab文件，里面存放了系统的调度程序。除此之外，每个用户都可以建立自己的crontab。这些用户自己的crontab文件在/var/spool/cron/username目录下。比如我的文件夹就是/var/spool/cron/alex。</p>
<p>crontab命令的用法简单而功能强大：用户只要编辑一个文本文档，就可以让crontab在规定的时间间隔里执行相应的命令。编辑这个文件的格式如下图所示：</p>
<img src="http://asxalex.qiniudn.com/crontab.png">
<a id="more"></a>
<p>如上图所示，crontab中共有6个字段，前5个字段用于确定command的执行频率（容易看出，命令执行之间的间隔时间最小是1分钟）。最后一个字段用于制定所需要完成的动作。在实际应用中，我们可以使用如下命令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ crontab -l #查看用户此时的crontab中的内容</div><div class="line">$ crontab -e #调用编辑器，让用户自己编辑crontab中的内容</div></pre></td></tr></table></figure>
<p>在自己编辑crontab中的内容时，前5个字段的每个字段都有相同的格式，说明如下：</p>
<ul>
<li><p>具体数字代表在那个时刻执行；</p>
</li>
<li><p>*是一个通配符，表示每个时间单位都要执行；</p>
</li>
<li><p>a-b表示在a-b个时间单位内都要执行，其他时间单位不执行；</p>
</li>
<li><p>*/n 表示每隔n个时间单位执行一次；</p>
</li>
<li><p>a,b,c 表示在a，b，c这三个时间单位点上要执行；</p>
</li>
</ul>
<p>举个栗子：</p>
<blockquote>
<p>*/5 2-12 *2 1-3,6-12 * /home/alex/colorful-life.sh</p>
</blockquote>
<p>根据格式说明，以上一段的意思是：在一年中，除了4月和5月之外的其他月份，在每月的2号，12号，22号3天中，从凌晨2点到中午12点，每5分钟执行一次/home/alex/colorful-life.sh这个脚本。</p>
<p>我第一次使用的测试例子如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * date | sed 's/\ \&#123;2,\&#125;/\ /g' | cut -d ' ' -f 4 | xargs echo &gt;&gt; myalex</div></pre></td></tr></table></figure>
<p>执行到现在，myalex中的文本如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="number">13</span>:<span class="number">03</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">04</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">05</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">06</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">07</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">08</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">09</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">10</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">11</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">12</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">13</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">14</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">15</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">16</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">17</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">18</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">19</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">20</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">21</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">22</span>:<span class="number">01</span></div><div class="line"><span class="number">13</span>:<span class="number">23</span>:<span class="number">01</span></div></pre></td></tr></table></figure>
<p>（EOF）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux下面有许许多多有用的工具，能够极大解放生产力。crontab就是其中的一个工具软件。&lt;/p&gt;
&lt;p&gt;crontab用于在一定的时间间隔调度一些命令的执行（以一定的频率执行用户事先确定好的命令，脚本等）。系统有一个/etc/crontab文件，里面存放了系统的调度程序。除此之外，每个用户都可以建立自己的crontab。这些用户自己的crontab文件在/var/spool/cron/username目录下。比如我的文件夹就是/var/spool/cron/alex。&lt;/p&gt;
&lt;p&gt;crontab命令的用法简单而功能强大：用户只要编辑一个文本文档，就可以让crontab在规定的时间间隔里执行相应的命令。编辑这个文件的格式如下图所示：&lt;/p&gt;
&lt;img src=&quot;http://asxalex.qiniudn.com/crontab.png&quot;&gt;
    
    </summary>
    
    
      <category term="CoolTool" scheme="http://asxalex.pw/tags/CoolTool/"/>
    
  </entry>
  
  <entry>
    <title>使用tmux</title>
    <link href="http://asxalex.pw/2013/08/31/tmux/"/>
    <id>http://asxalex.pw/2013/08/31/tmux/</id>
    <published>2013-08-31T12:12:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>tmux是一个终端复用软件。最早接触这个软件是在大概一年之前吧。那时候用的还是ubuntu 10.04 gnome桌面，用gnome桌面最大的缺点就是：在桌面上开了多个终端之后，终端之间的切换比较麻烦。那时候我通过google结识了终端复用软件——tmux。网络上说tmux是一款比screen还好用的终端复用软件（具体screen怎样，我也没用过，也不好下论断。）对于tmux，它的最大优点之一为：即使不正常断线，它还是可以保证当前任务运行完成。先前我也没有大量要使用ssh、telnet等远程服务，所以也体会不到它这个优点。但是，在我那会使用tmux时感觉确实挺好用——虽然没有进行大量的自己配置，但搭配快捷键后比在gnome下Ctrl-Tab键高效了许多。<a id="more"></a>不久之后，我就找到了i3wm这个平铺式窗口管理器，在这个窗口管理器下的终端切换甚是方便，以至于以后就再没碰过tmux。</p>
<p>这几天把我RPi的无线网卡给驱动上了，于是以后每次玩它都需要通过ssh。于是我马上想到了tmux。起初我还想把tmux的快捷键配置得像我的i3一样——这样可以省去很多学习成本——但似乎不行。tmux需要一个prefix，然后再是组合键，而i3纯粹是通过组合键来操作的。虽然无法将它改到我熟悉的快捷键配置，但我通过网上的配置教程把它配置得更美观、更符合我的使用习惯:-)</p>
<p>先来看一下我的tmux配置后的效果图：</p>
<img src="http://asxalex.qiniudn.com/tmux.png">
<p>tmux是典型的C/S架构。  </p>
<ul>
<li><p>session: 是一个特定的终端组合，输入tmux就打开一个session，另外，可以用tmux attach [-t id]来切换到id的session；</p>
</li>
<li><p>window: window为一个session中的终端，上图有两个运行bash的终端；</p>
</li>
<li><p>pane: pane为一个window中的终端，可以像上图一样任意调整大小</p>
</li>
</ul>
<p>以下为我的配置文件，这个配置文件既不是一个配置教程，也不包含所有配置选项，这只是我参照网上的配置文件进行就该的，自给自足:-) 若有需要完整教程的，请移至<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux&amp;sektion=1" target="_blank" rel="external">这里</a></p>
<figure class="highlight"><figcaption><span>~/.tmux.conf</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#set the windown name according to the app</div><div class="line">setw -g automatic-rename</div><div class="line"></div><div class="line">setw -g mode-keys vi</div><div class="line"></div><div class="line">unbind &amp;</div><div class="line">bind q kill-window</div><div class="line"></div><div class="line">unbind *</div><div class="line">bind * list-clients</div><div class="line"></div><div class="line">#move focus on adjacent pane</div><div class="line">bind h select-pane -L</div><div class="line">bind j select-pane -D</div><div class="line">bind k select-pane -U</div><div class="line">bind l select-pane -R</div><div class="line"></div><div class="line">#highlight acitve window</div><div class="line">set-window-option -g window-status-current-bg black</div><div class="line">set-window-option -g window-status-current-fg red</div><div class="line"></div><div class="line">#specify statusbar</div><div class="line">set -g status-justify left</div><div class="line">set -g status-left-length 30</div><div class="line">set -g status-left '[ #H]'</div><div class="line">set -g status-right-length 40</div><div class="line">set -g status-right '#[tmux-mem-cpu-load 1] #(date +"%Y-%m-%d %H:%M") Load:#(uptime | cut -d: -f5)'</div><div class="line">set -g display-time 5000</div><div class="line">set -g status-bg black</div><div class="line">set -g status-fg green</div><div class="line">set-window-option -g window-status-current-attr bright</div><div class="line"></div><div class="line">#notify if other window has activities</div><div class="line">setw -g clock-mode-colour red</div><div class="line">setw -g clock-mode-style 24</div><div class="line"></div><div class="line">#resize the pane</div><div class="line">bind-key J resize-pane -D 10</div><div class="line">bind-key K resize-pane -U 10</div><div class="line">bind-key H resize-pane -L 10</div><div class="line">bind-key L resize-pane -R 10</div></pre></td></tr></table></figure>
<p>具体的针对session、window还有pane的操作可以在manual page上找到,也可以在tmux里面用<strong>C-b ?</strong>来查询，这里就不作介绍了。就是这样，喵～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tmux是一个终端复用软件。最早接触这个软件是在大概一年之前吧。那时候用的还是ubuntu 10.04 gnome桌面，用gnome桌面最大的缺点就是：在桌面上开了多个终端之后，终端之间的切换比较麻烦。那时候我通过google结识了终端复用软件——tmux。网络上说tmux是一款比screen还好用的终端复用软件（具体screen怎样，我也没用过，也不好下论断。）对于tmux，它的最大优点之一为：即使不正常断线，它还是可以保证当前任务运行完成。先前我也没有大量要使用ssh、telnet等远程服务，所以也体会不到它这个优点。但是，在我那会使用tmux时感觉确实挺好用——虽然没有进行大量的自己配置，但搭配快捷键后比在gnome下Ctrl-Tab键高效了许多。
    
    </summary>
    
    
      <category term="CoolTool" scheme="http://asxalex.pw/tags/CoolTool/"/>
    
  </entry>
  
  <entry>
    <title>traits</title>
    <link href="http://asxalex.pw/2013/08/29/traits/"/>
    <id>http://asxalex.pw/2013/08/29/traits/</id>
    <published>2013-08-29T14:50:00.000Z</published>
    <updated>2016-11-14T09:38:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>traits是特点的意思。在c++中，traits class用于表现<strong>类型</strong>信息。容器类型利用模板可以包容不同类型的数据，如 std::vector\<int\> 就包含了int类型的数据，而 std::deque\<string\> 则包含了string类型的数据。c++利用traits技术来获得对象的类型信息。在我们获取不同对象的类型信息之后，就可以根据对象类型的不同而采取不同的操作。<a id="more"></a>下面是我们自己模拟的实例（无甚意义）。我们定义了两个类模板：MyType 和 YourType（我承认名字起得太。。了 -_-!）先看如下代码：</string\></int\></p>
<figure class="highlight c++"><figcaption><span>traits.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> my_type&#123;&#125;;</div><div class="line"><span class="keyword">struct</span> your_type&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> MyType&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> my_type value_type;</div><div class="line">        MyType(<span class="keyword">const</span> T&amp; a):content(a)&#123;&#125;</div><div class="line">        MyType&amp; <span class="keyword">operator</span>++()&#123;<span class="keyword">this</span> -&gt; content ++;<span class="keyword">return</span> (*<span class="keyword">this</span>);&#125;</div><div class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">get_content</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> content;&#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T content;</div><div class="line">&#125;;</div><div class="line">        </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> YourType &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> your_type value_type;</div><div class="line">        YourType(<span class="keyword">const</span> T&amp; a): content(a)&#123;&#125;</div><div class="line">        YourType&amp; <span class="keyword">operator</span>+=(<span class="keyword">int</span> a)&#123;<span class="keyword">this</span> -&gt; content+=a; <span class="keyword">return</span> (*<span class="keyword">this</span>);&#125;</div><div class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">get_content</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> content;&#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T content;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> traits&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increase</span><span class="params">(T&amp; a,<span class="keyword">int</span> steps)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"derived : "</span> &lt;&lt; (<span class="keyword">typeid</span>(your_type)== <span class="keyword">typeid</span>(my_type)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(<span class="keyword">typename</span> traits&lt;T&gt;::value_type) == <span class="keyword">typeid</span>(my_type))&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps; ++i)&#123;</div><div class="line">            ++a;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"added once and now is "</span> &lt;&lt; a.get_content() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeid</span>(<span class="keyword">typename</span> traits&lt;T&gt;::value_type) == <span class="keyword">typeid</span>(your_type))&#123;</div><div class="line">        a += steps;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"now is "</span> &lt;&lt; a.get_content() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"error occured!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>traits.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"trait.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    YourType&lt;<span class="keyword">int</span>&gt; you(<span class="number">123</span>);</div><div class="line">    Increase(t,<span class="number">12</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; you.get_content() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    MyType&lt;<span class="keyword">int</span>&gt; me(<span class="number">21</span>);</div><div class="line">    Increase(me,<span class="number">5</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; me.get_content() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过traits技术，我们在可以在编译时期得到对象的类型,并在Increase函数中根据类型采取不同的增加content成员的方法：若类型为MyType，我的类型<strong>只</strong>支持前缀++，所以我们用循环来递增；而若类型为YourType时，你的类型<strong>只</strong>支持+=操作符，可以一步到位。一切看上去如此美好！但很遗憾，上面的代码通不过编译：</p>
<figure class="highlight"><figcaption><span>error message</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">In file included from trait.cpp:1:0:</div><div class="line">trait.h: In function ‘void Increase(T&amp;, int) [with T = YourType&lt;int&gt;]’:</div><div class="line">trait.cpp:5:18:   instantiated from here</div><div class="line">trait.h:63:13: error: no match for ‘operator++’ in ‘++a’</div><div class="line">trait.h: In function ‘void Increase(T&amp;, int) [with T = MyType&lt;int&gt;]’:</div><div class="line">trait.cpp:7:20:   instantiated from here</div><div class="line">trait.h:68:9: error: no match for ‘operator+=’ in ‘a += steps’</div></pre></td></tr></table></figure>
<p>出错的原因就是因为上面的<strong>只</strong>字，这在编译错误信息里写得很明确了：MyType没定义+=操作符，而YourType没定义++操作符。为解决这个问题，我们可以在traits中增加一个隔离层，并在其中定义++与+=两种操作符，利用traits的++或+=调用实际的操作符，或者提示没这个方法的信息。除了这个方法，我们也可以利用模板函数的重载来消除这个操作符未定义的问题：</p>
<figure class="highlight c++"><figcaption><span>traits.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> my_type&#123;&#125;;</div><div class="line"><span class="keyword">struct</span> your_type&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> MyType&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> my_type value_type;</div><div class="line">        MyType(<span class="keyword">const</span> T&amp; a):content(a)&#123;&#125;</div><div class="line">        MyType&amp; <span class="keyword">operator</span>++()&#123;<span class="keyword">this</span> -&gt; content ++;<span class="keyword">return</span> (*<span class="keyword">this</span>);&#125;</div><div class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">get_content</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> content;&#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T content;</div><div class="line">&#125;;</div><div class="line">        </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> YourType &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> your_type value_type;</div><div class="line">        YourType(<span class="keyword">const</span> T&amp; a): content(a)&#123;&#125;</div><div class="line">        YourType&amp; <span class="keyword">operator</span>+=(<span class="keyword">int</span> a)&#123;<span class="keyword">this</span> -&gt; content+=a; <span class="keyword">return</span> (*<span class="keyword">this</span>);&#125;</div><div class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">get_content</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> content;&#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        T content;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> traits&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIncrease</span><span class="params">(T&amp; a,<span class="keyword">int</span> steps,my_type)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps; ++i)&#123;</div><div class="line">        ++a;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"added once and now is "</span> &lt;&lt; a.get_content() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doIncrease</span><span class="params">(T&amp; a, <span class="keyword">int</span> steps,your_type)</span></span>&#123;</div><div class="line">    a += steps;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increase</span><span class="params">(T&amp; a, <span class="keyword">int</span> steps)</span></span>&#123;</div><div class="line">    doIncrease(a, steps, <span class="keyword">typename</span> traits&lt;T&gt;::value_type());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在真正调用Increase函数时，Increase函数首先获取对象的类型信息，并通过具体的类型来调用不同版本的doIncrease函数，实际的递增操作是在doIncrease里面完成的。这样就不会存在以上的警告信息了。</p>
<figure class="highlight c++"><figcaption><span>result</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">135</span></div><div class="line">dded once and now is <span class="number">22</span></div><div class="line">added once and now is <span class="number">23</span></div><div class="line">added once and now is <span class="number">24</span></div><div class="line">added once and now is <span class="number">25</span></div><div class="line">added once and now is <span class="number">26</span></div><div class="line"><span class="number">26</span></div></pre></td></tr></table></figure>
<p>以上结果说明了该程序根据类型的不同，“选择”了不同的递增路线，达到了我们使用traits的目的。</p>
<p>另外，traits的技术要求之一是，它对内置（built-in）类型和用户自定义类型的表现必须一样好。在实际使用中，我们可以利用traits模板的偏特化来达到这个目的。在此不详细展开了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;traits是特点的意思。在c++中，traits class用于表现&lt;strong&gt;类型&lt;/strong&gt;信息。容器类型利用模板可以包容不同类型的数据，如 std::vector\&lt;int\&gt; 就包含了int类型的数据，而 std::deque\&lt;string\&gt; 则包含了string类型的数据。c++利用traits技术来获得对象的类型信息。在我们获取不同对象的类型信息之后，就可以根据对象类型的不同而采取不同的操作。
    
    </summary>
    
    
      <category term="cpp" scheme="http://asxalex.pw/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>继承与多态浅析</title>
    <link href="http://asxalex.pw/2013/08/27/polymorphism/"/>
    <id>http://asxalex.pw/2013/08/27/polymorphism/</id>
    <published>2013-08-27T11:27:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象程序设计中两个重要的概念是继承性与多态性。通俗地讲，继承性是指派生类从基类中获得基类的成员变量及成员函数；而多态性是指在运行时根据对象实际类型确定实际调用的操作，实现“一个接口，多种实现”。在c++中，多态性是通过virtual函数实现的。在子类中通过重写父类中的virtual函数完成，而c++亦允许在子类中对父类的非virtual函数进行重写，一下就来剖析一下这两者的不同。<a id="more"></a></p>
<p>我们首先看一个例子，该例子的类图如下：</p>
<img src="http://asxalex.qiniudn.com/compare.png">
<p>代码如下：</p>
<figure class="highlight c++"><figcaption><span>compare.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Base&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func1 in Base, virtual."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func2 in Base, non-virtual."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func2 in Base with arg "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func1 in Derived, virtual."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func2 in Derived, non-virtual."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>compare.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"compare.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    Base *base1 = <span class="keyword">new</span> Derived();</div><div class="line">    base1 -&gt; func1();</div><div class="line">    base1 -&gt; func2();</div><div class="line">    base1 -&gt; func2(<span class="number">12</span>);</div><div class="line">    Derived *derived1 = <span class="keyword">new</span> Derived();</div><div class="line">    derived1 -&gt; func1();</div><div class="line">    derived1 -&gt; func2();</div><div class="line">    </div><div class="line">    <span class="comment">//derived1 -&gt; func2(12);</span></div><div class="line">    Derived derived2;</div><div class="line">    Base base2 = derived2;</div><div class="line">    base2.func1();</div><div class="line">    base2.func2();</div><div class="line">    base2.func2(<span class="number">123</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func1 in Derived, <span class="keyword">virtual</span></div><div class="line">func2 in Base, non-<span class="keyword">virtual</span></div><div class="line">func2 in Base with arg <span class="number">12</span></div><div class="line">func1 in Derived, <span class="keyword">virtual</span></div><div class="line">func2 in Derived, non-<span class="keyword">virtual</span></div><div class="line">func1 in Base, <span class="keyword">virtual</span></div><div class="line">func2 in Base, non-<span class="keyword">virtual</span></div><div class="line">func2 in Base with arg <span class="number">123</span></div></pre></td></tr></table></figure>
<p>从结果可以看出：对基类中的virtual函数进行重写之后，可以用基类的指针（或引用）在运行时动态绑定其子类中的相应实现（多态性）；对基类中的非virtual函数进行重写之后，用基类的指针（或引用）只能访问基类中的函数实现；当用派生类的指针来调用函数时，访问方法遵循作用域规则，作用域如下：</p>
<img src="http://asxalex.qiniudn.com/field.png">
<p>以上通过derived1调用func2()时，在derived作用域中找到了func2()的定义，而当调用derived1 -&gt; func2(12)时，在Derived类的作用域中找到了func2函数，但调用方式不对，于是编译出错；当用一个Derived对象初始化一个Base对象时，Derived对象中的Base部分被复制给Base对象，以后，通过Base对象访问的函数均在Base中，而不管是否是virtual。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象程序设计中两个重要的概念是继承性与多态性。通俗地讲，继承性是指派生类从基类中获得基类的成员变量及成员函数；而多态性是指在运行时根据对象实际类型确定实际调用的操作，实现“一个接口，多种实现”。在c++中，多态性是通过virtual函数实现的。在子类中通过重写父类中的virtual函数完成，而c++亦允许在子类中对父类的非virtual函数进行重写，一下就来剖析一下这两者的不同。
    
    </summary>
    
    
      <category term="cpp" scheme="http://asxalex.pw/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry pi配置使用无线网卡</title>
    <link href="http://asxalex.pw/2013/08/26/raspberrypi/"/>
    <id>http://asxalex.pw/2013/08/26/raspberrypi/</id>
    <published>2013-08-26T15:44:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>前天刚到校，翻出了闲置很久的Rpi。那时候在买之前，我就下决心要好好利用它，但要将它连上校园网却不是很简单。没有网络的系统就像一潭死水一样毫无生机。就算你事先将许多软件安装好，在你开发时也常常会遇到某些工具软件没安装的情况，这会让人十分苦恼。而且手工安装缺失的软件实在不是一种明智的选择————linux下的包依赖关系几乎是无法手工管理的。</p>
<p>为了连上网络，我以前也尝试过使用linux客户端进行少量的修改来认证，但毕竟架构不同，尝试了许多最终还是以失败告终。遂将其闲置了几个月。<a id="more"></a></p>
<p>后来，同学有个闲置的路由器，我也闲着没事，就将它的路由器刷了个openwrt系统。后来抱着试试看的态度，将我电脑里的认证的bin文件拷贝进路由器试着进行认证。让我吃惊的是那个竟然能认证成功！于是，只要在路由器里进行认证，而连接到这个局域网的电脑、手机什么的都不需要认证了。由于Rpi上只有一个ethernet接口，我又买了根网线链接到路由器的Lan口，在一阵鼓捣之后终于ping通了8.8.8.8，一阵兴奋之后，我就将一些常用的软件（vim、ipython等）安装上去了。但后来发现这个方法不是很稳定（或者说很是不稳定）：路由器要连续认证好多次才能真正上网、一旦用了Lan口，其他设备连上wifi就无法上网……这一系列问题又让Rpi在黑暗的角落待了好几个月。</p>
<p>这次在网上看到了可以用usb无线网卡来让Rpi连接进网络。在论坛里逛了好久，看到许多人说NW336 150M无线网卡免驱就能被raspbian识别。我今天上午9点多下的单，到下午3点货就到了（这速度，太给力了）。拿到之后我一阵欣喜地试了下，但没有出现像网上所说的一样，免驱就能使用。ifconfig -a始终没有出现期待的wlan0   :(</p>
<p>经google良久才发现端倪：他们的lsusb出现的是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pi@raspberrypi:/$ lsusb</div><div class="line">Bus <span class="number">001</span> Device <span class="number">001</span>: ID <span class="number">1</span>d6b:<span class="number">0002</span> Linux Foundation <span class="number">2.0</span> root hub</div><div class="line">Bus <span class="number">001</span> Device <span class="number">002</span>: ID <span class="number">0424</span>:<span class="number">9512</span> Standard Microsystems Corp.</div><div class="line">Bus <span class="number">001</span> Device <span class="number">003</span>: ID <span class="number">0424</span>:ec00 Standard Microsystems Corp.</div><div class="line">Bus <span class="number">001</span> Device <span class="number">004</span>: ID <span class="number">0b</span>da:<span class="number">8176</span> Realtek Semiconductor Corp. RTL8188CUS <span class="number">802.11</span>n WLAN Adapter</div></pre></td></tr></table></figure>
<p>而我的是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pi@raspberrypi:/$ sudo lsusb</div><div class="line">Bus <span class="number">001</span> Device <span class="number">001</span>: ID <span class="number">1</span>d6b:<span class="number">0002</span> Linux Foundation <span class="number">2.0</span> root hub</div><div class="line">Bus <span class="number">001</span> Device <span class="number">002</span>: ID <span class="number">0424</span>:<span class="number">9512</span> Standard Microsystems Corp.</div><div class="line">Bus <span class="number">001</span> Device <span class="number">003</span>: ID <span class="number">0424</span>:ec00 Standard Microsystems Corp.</div><div class="line">Bus <span class="number">001</span> Device <span class="number">004</span>: ID <span class="number">0b</span>da:<span class="number">8179</span> Realtek Semiconductor Corp.</div></pre></td></tr></table></figure>
<p>这个命令显示的usb id不一样，我这个网卡的芯片是8188eu，而论坛里大家的网卡芯片是8192cu，顺着这个继续google，历经千辛万苦，终于让我找到了解决方案：在github上有基于8192cu基础上修改的8188eu的<a href="https://github.com/Red54/linux-shumeipai2/tree/sunxi-3.0/drivers/net/wireless/rtl8188eu" target="_blank" rel="external">驱动代码</a></p>
<p>下载源码之后，正式编译之前，我们首先需要修改makefile里的编译选项，其默认配置是i386平台：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">CONFIG_PLATFORM_I386_PC = y</div><div class="line">CONFIG_PLATFORM_ANDROID_X86 = n</div><div class="line">CONFIG_PLATFORM_ARM_S3C2K4 = n</div><div class="line">CONFIG_PLATFORM_ARM_PXA2XX = n</div><div class="line">...</div></pre></td></tr></table></figure>
<p>由于Rpi是BCM2708平台，所以修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">CONFIG_PLATFORM_I386_PC = n</div><div class="line">CONFIG_PLATFORM_BCM2708 = y</div><div class="line">CONFIG_PLATFORM_ANDROID_X86 = n</div><div class="line">CONFIG_PLATFORM_ARM_S3C2K4 = n</div><div class="line">CONFIG_PLATFORM_ARM_PXA2XX = n</div><div class="line">...</div></pre></td></tr></table></figure>
<p>之后需要创建新增的目标平台的配置选项，在Makefile里有如下几行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ifeq ($(CONFIG_PLATFORM_I386_PC), y)</div><div class="line">EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN</div><div class="line">SUBARCH := $(shell uname -m | sed -e s/i<span class="number">.86</span>/i386/)</div><div class="line">ARCH ?= $(SUBARCH)</div><div class="line">CROSS_COMPILE ?=</div><div class="line">KVER := $(shell uname -r)</div><div class="line">KSRC := /lib/modules/$(KVER)/build</div><div class="line">MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/</div><div class="line">INSTALL_PREFIX :=</div><div class="line">endif</div><div class="line"> </div><div class="line">ifeq ($(CONFIG_PLATFORM_TI_AM3517), y)</div><div class="line">EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_SHUTTLE</div><div class="line">CROSS_COMPILE := arm-eabi-</div><div class="line">KSRC := $(shell pwd)/../../../Android/kernel</div><div class="line">ARCH := arm</div><div class="line">endif</div><div class="line">...</div></pre></td></tr></table></figure>
<p>在之间添加配置选项，结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">ifeq ($(CONFIG_PLATFORM_I386_PC), y)</div><div class="line">EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN</div><div class="line">SUBARCH := $(shell uname -m | sed -e s/i<span class="number">.86</span>/i386/)</div><div class="line">ARCH ?= $(SUBARCH)</div><div class="line">CROSS_COMPILE ?=</div><div class="line">KVER := $(shell uname -r)</div><div class="line">KSRC := /lib/modules/$(KVER)/build</div><div class="line">MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/</div><div class="line">INSTALL_PREFIX :=</div><div class="line">endif</div><div class="line"> </div><div class="line">ifeq ($(CONFIG_PLATFORM_BCM2708), y)</div><div class="line">EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN</div><div class="line">ARCH := arm</div><div class="line">CROSS_COMPILE :=</div><div class="line">KVER := $(shell uname -r)</div><div class="line">KSRC := /lib/modules/$(KVER)/build</div><div class="line">MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless</div><div class="line">INSTALL_PREFIX :=</div><div class="line">MODULE_NAME := <span class="number">8188</span>eu</div><div class="line">endif</div><div class="line"></div><div class="line">ifeq ($(CONFIG_PLATFORM_TI_AM3517), y)</div><div class="line">EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_SHUTTLE</div><div class="line">CROSS_COMPILE := arm-eabi-</div><div class="line">KSRC := $(shell pwd)/../../../Android/kernel</div><div class="line">ARCH := arm</div><div class="line">endif</div><div class="line">...</div></pre></td></tr></table></figure>
<p>之后make之，得到8188eu.ko,将其install至对应地点：</p>
<blockquote>
<p>sudo install 8188eu.ko /lib/modules/3.6.11+/kernel/drivers/net/wireless/8188eu.ko  </p>
<p>sudo depmod -a  </p>
<p>sudo modprobe 8188eu  </p>
</blockquote>
<p>经过以上几步，当我们再次ifconfig -a时，就能看到wlan0了。之后，就是可以通过wlan0连接到无线网络啦:) 当看到用我的Rpi可以ping通这个blog时真的好兴奋！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天刚到校，翻出了闲置很久的Rpi。那时候在买之前，我就下决心要好好利用它，但要将它连上校园网却不是很简单。没有网络的系统就像一潭死水一样毫无生机。就算你事先将许多软件安装好，在你开发时也常常会遇到某些工具软件没安装的情况，这会让人十分苦恼。而且手工安装缺失的软件实在不是一种明智的选择————linux下的包依赖关系几乎是无法手工管理的。&lt;/p&gt;
&lt;p&gt;为了连上网络，我以前也尝试过使用linux客户端进行少量的修改来认证，但毕竟架构不同，尝试了许多最终还是以失败告终。遂将其闲置了几个月。
    
    </summary>
    
    
      <category term="Fun" scheme="http://asxalex.pw/tags/Fun/"/>
    
  </entry>
  
  <entry>
    <title>《清醒思考的艺术》读后感</title>
    <link href="http://asxalex.pw/2013/08/24/qing-xing-si-kao-de-yi-zhu/"/>
    <id>http://asxalex.pw/2013/08/24/qing-xing-si-kao-de-yi-zhu/</id>
    <published>2013-08-24T14:02:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>《清醒思考的艺术》是一本比较薄的书，我是完全利用零碎时间把它读完的。我读书喜欢先看目录，从中挑选自己感兴趣的内容先看看，若是感觉讲得好，讲得在理，就继续从头开始读。这是一本我愿意从头读到尾的书。</p>
<p>我们的生活中充满了选择，我们几乎每天都要面对选择：要去A超市还是B超市，要继续干某件事还是就此放弃，要……而在这些选择背后决定我们选择的是我们的思维。但是，正如书中所说（大致意思）：我们的思维并不能像手脚一样毫无错误，而会经常犯错误。如果我们能理性分析一下我们的行为以及行为背后的思维，我们就会发现在我们生活中，甚至是我们习以为常的决定，都会存在相当的不合理性。<a id="more"></a>这本书就像它的副标题所说——你最好让别人去犯的52种思维错误——列举了52个真实例子或寓言，从中剖析隐藏在这些例子中的思维错误。</p>
<img src="http://asxalex.qiniudn.com/pho.png" title="清醒思考的艺术">
<p>在每个实例中，作者首先从一个真实事件或是寓言中引出我们<strong>看似正确的错误决策</strong>。当看到这些例子时，若我设身处地地想想那个情景，十有八九我会犯同样的错误——正式这个才凸显了这本书的价值。之后，作者会分析隐藏在这个错误决策背后的心理和思维错误——或从进化心理学的角度，或是从人某个心理弱点出发。我读到这里都会有一种恍然大悟的感觉——原来是这个心理在作祟……最后，每节都会给出一个结论，这给我们一个指引：在某些情况下应该怎样做才能避免类似错误。</p>
<p>这本书的书名是《清醒思考的艺术》——凡到“艺术”，我认为是做<strong>一类事情</strong>的方法，但这本书所述是52个活生生的例子，还没到<strong>一类</strong>的地步。所以，我们需<strong>自行拓展</strong>：要能够清晰地看出我们日常生活中某些错误决策背后的思维错误，这样才能尽量避免因为思维错误导致的心理或者生理上的不愉悦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《清醒思考的艺术》是一本比较薄的书，我是完全利用零碎时间把它读完的。我读书喜欢先看目录，从中挑选自己感兴趣的内容先看看，若是感觉讲得好，讲得在理，就继续从头开始读。这是一本我愿意从头读到尾的书。&lt;/p&gt;
&lt;p&gt;我们的生活中充满了选择，我们几乎每天都要面对选择：要去A超市还是B超市，要继续干某件事还是就此放弃，要……而在这些选择背后决定我们选择的是我们的思维。但是，正如书中所说（大致意思）：我们的思维并不能像手脚一样毫无错误，而会经常犯错误。如果我们能理性分析一下我们的行为以及行为背后的思维，我们就会发现在我们生活中，甚至是我们习以为常的决定，都会存在相当的不合理性。
    
    </summary>
    
    
      <category term="Books" scheme="http://asxalex.pw/tags/Books/"/>
    
  </entry>
  
  <entry>
    <title>设计模式（21）——模板方法模式</title>
    <link href="http://asxalex.pw/2013/08/21/template-method/"/>
    <id>http://asxalex.pw/2013/08/21/template-method/</id>
    <published>2013-08-21T05:23:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>模板方法模式（Template Method）定义操作中一个算法的架构而将一些步骤延迟到子类中。它使得一个子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>考虑一个我们应聘时填写表格的步骤：我们需要填写个人信息、教育背景以及项目经验。每个应聘者都需要填写这些内容。所以我们可以从这些填写步骤中抽象出一些算法的<strong>骨架</strong>。虽然每个人具体要填写的内容不同，但填写的步骤一样。当从定义好骨架的基类派生出子类时，我们可以根据个人情况重定义填写内容，而与算法架构无关。<a id="more"></a>看下面类图：</p>
<img src="http://asxalex.qiniudn.com/template_method.png">
<p>代码如下：</p>
<figure class="highlight c++"><figcaption><span>template_method.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> resume&#123;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setPersonalInfo</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEducation</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setWorkExp</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fillForm</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use base class"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">            setPersonalInfo();</div><div class="line">            setEducation();</div><div class="line">            setWorkExp();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> resumeA : <span class="keyword">public</span> resume&#123;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setPersonalInfo</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Set A's Personal Infomation"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEducation</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set A's Education infomation"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setWorkExp</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set A's Work experience infomation"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fillForm</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use sub class"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">            setPersonalInfo();</div><div class="line">            setEducation();</div><div class="line">            setWorkExp();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> resumeB : <span class="keyword">public</span> resume&#123;</div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setPersonalInfo</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set B's Personal Infomation"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setEducation</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set B's Education Infomation"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setWorkExp</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set B's Work experience infomation"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fillForm</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use sub class"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">            setPersonalInfo();</div><div class="line">            setEducation();</div><div class="line">            setWorkExp();</div><div class="line">        &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>template_method.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"template_method.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    resume *res = <span class="keyword">new</span> resumeA;</div><div class="line">    res -&gt; fillForm();</div><div class="line">    resumeB res2;</div><div class="line">    res2.fillForm();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（EOF）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模板方法模式（Template Method）定义操作中一个算法的架构而将一些步骤延迟到子类中。它使得一个子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;考虑一个我们应聘时填写表格的步骤：我们需要填写个人信息、教育背景以及项目经验。每个应聘者都需要填写这些内容。所以我们可以从这些填写步骤中抽象出一些算法的&lt;strong&gt;骨架&lt;/strong&gt;。虽然每个人具体要填写的内容不同，但填写的步骤一样。当从定义好骨架的基类派生出子类时，我们可以根据个人情况重定义填写内容，而与算法架构无关。
    
    </summary>
    
    
      <category term="DesignPatterns" scheme="http://asxalex.pw/tags/DesignPatterns/"/>
    
  </entry>
  
  <entry>
    <title>设计模式（20）——策略模式</title>
    <link href="http://asxalex.pw/2013/08/21/strategy/"/>
    <id>http://asxalex.pw/2013/08/21/strategy/</id>
    <published>2013-08-21T05:04:00.000Z</published>
    <updated>2016-11-14T09:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式（Strategy）定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。此模式可以使得算法可独立于使用他们的客户的变化而变化。</p>
<p>比如说我们现在要去某个风景名胜旅游。于是你在网上查好了路线。有许多策略：你可以选择A——B——C——D，或者A——E——F——D，或者A——G——D。你可以不关心具体路线，只要到达目的就行。于是这些路线就成了算法，他们应该独立于我们客户——即我们可以随时更换这些策略。<a id="more"></a>为了简化，看下面的类图：</p>
<img src="http://asxalex.qiniudn.com/stategy.png">
<p>这是最简单的类之间的继承关系，实现代码如下：</p>
<figure class="highlight c++"><figcaption><span>strategy.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> APPROACH&#123;AP1, AP2&#125;;</div><div class="line"><span class="keyword">class</span> approach&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">means</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> approach1 : <span class="keyword">public</span> approach&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">means</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is approach one"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> approach2 : <span class="keyword">public</span> approach&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">means</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is approach two"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> select_approach&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        select_approach(APPROACH);</div><div class="line">        ~select_approach()&#123;<span class="keyword">delete</span> _app;&#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show_approach</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        approach *_app;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">select_approach::select_approach(APPROACH app)&#123;</div><div class="line">    <span class="keyword">switch</span>(app)&#123;</div><div class="line">        <span class="keyword">case</span> AP1:</div><div class="line">            _app = <span class="keyword">new</span> approach1;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> AP2:</div><div class="line">            _app = <span class="keyword">new</span> approach2;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            _app = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">void</span> select_approach::show_approach() <span class="keyword">const</span>&#123;</div><div class="line">    _app -&gt; means();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><figcaption><span>strategy.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"strategy.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function">select_approach <span class="title">sele_app1</span><span class="params">(AP1)</span></span>;</div><div class="line">    sele_app1.show_approach();</div><div class="line">    <span class="function">select_approach <span class="title">sele_app2</span><span class="params">(AP2)</span></span>;</div><div class="line">    sele_app2.show_approach();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个栗子中，我们通过向select_approach传递参数来选择具体的策略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;策略模式（Strategy）定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。此模式可以使得算法可独立于使用他们的客户的变化而变化。&lt;/p&gt;
&lt;p&gt;比如说我们现在要去某个风景名胜旅游。于是你在网上查好了路线。有许多策略：你可以选择A——B——C——D，或者A——E——F——D，或者A——G——D。你可以不关心具体路线，只要到达目的就行。于是这些路线就成了算法，他们应该独立于我们客户——即我们可以随时更换这些策略。
    
    </summary>
    
    
      <category term="DesignPatterns" scheme="http://asxalex.pw/tags/DesignPatterns/"/>
    
  </entry>
  
</feed>
